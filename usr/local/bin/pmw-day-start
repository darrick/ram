#!/bin/zsh
# shellcheck disable=SC2086

##############################################################################
##
## Based partially on a message that was originally posted to
## rivendell-dev by Wayne Merricks <waynemerricks@thevoiceasia.com>
## with Subject: "[RDD] Getting Airplay to Auto Play at correct time"
##
## BUT ALERT: This script assumes that tomorrows log has already been prepared!
##
## This script does not start the next log, it simply loads tomorrows
## log and makes (what should be) the Legal ID the next cart to
## play. This is to work around the seemingly broken setting at
## rdadmin -> Manage Services -> "Insert CHAIN TO at log end". You
## should most likely DISABLE that setting when using this script and
## the associated RML Macro.
##
## This is meant to be run non-interactively from either a cron job,
## or from another job scheduler such as rdcatch(1) at several seconds
## before midnight.
##
## This script should run ON the host running RDAirPlay!
##
##############################################################################

# Log STDOUT and STDERR to separate files.
exec 1> /var/tmp/${0##*/}.out
exec 2> /var/tmp/${0##*/}.err

zmodload zsh/datetime

# Optional argument names a log to load in the Auxiliary Log 1 machine.
if [[ -n "${1}" ]] ; then
  auxLog="${1}"
  shift
fi

## Locate the commands we need in this script.
LOGGER=$(whence logger) ; LOGGER=${LOGGER:-${ROOT:-/}usr/bin/logger}
RMLSEND=$(whence rmlsend) ; RMLSEND=${RMLSEND:-${ROOT:-/}usr/bin/rmlsend}

# Get zsh functions necessary for this script.
if [[ -r ${ROOT:-/}usr/local/bin/zsh-functions ]] ; then
  # shellcheck disable=SC1090
  source ${ROOT:-/}usr/local/bin/zsh-functions
else
  ${LOGGER} --stderr -t ${0##*/} -p local7.err -i "ERROR: Cannot find /usr/local/bin/zsh-functions. Cannot continue."
  exit 3
fi

# Calculate the the name of tomorrows log based on the current time.
timeNow=${EPOCHSECONDS}
oneDay=$(( 60 * 60 * 24 ))
hours=$(( $(strftime "%H" ${timeNow}) * 60 * 60 ))
minutes=$(( $(strftime "%M" ${timeNow}) * 60 ))
seconds=$(strftime "%S" ${timeNow})
secondsPastMidnight=$(( hours + minutes + seconds ))
tomorrow=$(( EPOCHSECONDS - secondsPastMidnight + oneDay ))

# Get the log name templates from the SERVICES table.
# These will be placed in an associative array indexed on the SERVICE name.
typeset -A logNameTemplates
# shellcheck disable=SC2190
# shellcheck disable=SC2207
logNameTemplates=( $(doSQL "SELECT name,name_template FROM SERVICES") )

# We may be loading logs for more than one SERVICE.
for service in ${(k)logNameTemplates} ; do

  # Rivendell uses %s for "Service Name", strftime uses %s for
  # "Seconds since the Epoch". "Manually" replace the %s with the
  # Service Name in the Log Template before substituting the date
  # stuff in the Log Template.
  if [[ ${logNameTemplates[${service}]} =~ %s ]] ; then
    ${logNameTemplates[${service}]} = ${logNameTemplates[${service}]//\%s/${service}}
  fi

  # Older shell versions are not up to snuff with respect to strftime(3).
  # shellcheck disable=SC2079
  if (( ZSH_VERSION < 5.6 )) ; then
    # shellcheck disable=SC2046
    nextLog=$(date --date=$(strftime "%F" ${tomorrow}) "+${logNameTemplates[${service}]}")
  else
    nextLog=$(strftime "${logNameTemplates[${service}]}" ${tomorrow})
  fi

  # Rivendell versions prior to version 3 tacked "_LOG" to the end of
  # the Log Name.
  if (( $(rdDatabaseVersion) < 300 )) ; then
    nextLog=${nextLog}_LOG
  fi

  # Verify that the log exists before running the macros
  nextLogLookup=$(doSQL "SELECT name FROM LOGS WHERE name = '${nextLog}'")

  if [[ -n "${nextLogLookup}" ]] ; then

    # What this here-doc does:
    # PW 1: Select Widget, "Main Log"
    # LL 1: Load Log, RDAirPlay load tomorrows log, but do not start it (-1)
    # auxLog: if the shell variable auxLog is set, load the named log in Auxiliary Log 1 (log machine 2)
    # MN 1: Make Next, the first cart in the log (line ID 0, should be a "Start Immediately", or "Make Next")
    # auxLog: if the shell variable auxLog is set, Make Next the first cart in Auxiliary Log 1 (line ID 0)
    # PM 2: Set Mode, RDAirPlay mode "Auto"
    if rmlsendOutput=$(${RMLSEND} --from-file=- 2>&1) <<EOF
PW 1!
LL 1 ${nextLog} -1!
${auxLog:+LL 2 ${auxLog}! -1}
MN 1 0!
${auxLog:+MN 2 0!}
PM 2!
EOF

    then

      ${LOGGER} --stderr -t ${0##*/} -p local7.info -i "INFO: rmlsend loaded tomorrow's log '${nextLog}'. rmlsend says: '${rmlsendOutput}'"

    else

      ${LOGGER} --stderr -t ${0##*/} -p local7.err -i "ERROR: rmlsend may not have loaded tomorrow's log '${nextLog}'. rmlsend says: '${rmlsendOutput}'"

    fi

  else

    ${LOGGER} --stderr -t ${0##*/} -p local7.warn -i "WARNING: the log '${nextLog}' is not in the Rivendell database. Did you generate the log?"

  fi

done

exit

# Local Variables: ***
# mode:shell-script ***
# indent-tabs-mode: f ***
# sh-indentation: 2 ***
# sh-basic-offset: 2 ***
# sh-indent-for-do: 0 ***
# sh-indent-after-do: + ***
# sh-indent-comment: t ***
# sh-indent-after-case: + ***
# sh-indent-after-done: 0 ***
# sh-indent-after-else: + ***
# sh-indent-after-if: + ***
# sh-indent-after-loop-construct: + ***
# sh-indent-after-open: + ***
# sh-indent-after-switch: + ***
# sh-indent-for-case-alt: ++ ***
# sh-indent-for-case-label: + ***
# sh-indent-for-continuation: + ***
# sh-indent-for-done: 0 ***
# sh-indent-for-else: 0 ***
# sh-indent-for-fi: 0 ***
# sh-indent-for-then: 0 ***
# End: ***
