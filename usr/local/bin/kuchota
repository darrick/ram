#!/bin/zsh

##########################################################################################
##########################################################################################
##
##
## kuchota (Swahili for "fetch")
##
## A PMW podget tool to manage podcast feeds (i.e., RSS, ATOM, etc.)
## and downloads by podget(1), for later import into a Rivendell
## library.
##
##########################################################################################
##########################################################################################

setopt REMATCH_PCRE
setopt NO_CASE_MATCH
zmodload zsh/regex
zmodload zsh/datetime
zmodload zsh/terminfo
autoload colors
colors

# This script complies with Semantic Versioning: http://semver.org/
vMajor=0
vMinor=1
vPatch=1
vHash='$Hash: 2d335f9$'

# Get zsh functions necessary for this script.
[[ -r ${ROOT:-/}usr/local/bin/zsh-functions ]] && source ${ROOT:-/}usr/local/bin/zsh-functions

##########################################################################################
## Locally defined subroutines
##########################################################################################

# How to use this command.
usage() {
  myName=${1}

  ${CAT} << EOF
${myName}: add a new RSS feed to the list of podcasts.

Summary: ${myName##*/} [ --verbose (-v) ] [ --debug (-D) ] [ --version (-V) ]
                       [ --config (-c) <podget_configuration_file> ]
                       [ --dir_config (-d) <podget_configuration_directory> ]
                       [ --group (-g) { <Rivendell Group Name> or 'list' } ]

You may use the word "list" for the --group (-g) option.
This will cause ${myName##*/} to list the available groups and
prompt you for which one to use for this podcast.

EOF
}

addOrReplaceFeed() {
  local myName=${1} ; shift
  local verbose=${1}

  local feedURL feedUser feedPassword protocol hostANDport route urlWithCredentials titleParserXSL
  local feedTitle name group rivendellGroupList
  local ok

  read feedURL\?"Type or paste the RSS feed URL for this podcast: "

  read -q ok\?"Does this podcast download require a username? [y,N] "
  echo
  if [[ "${ok}" = y ]] ; then
    read feedUser\?"Enter the feed username: "

    read -q ok\?"Does this URL require a password for the user ${feedUser}? [y,N] "
    echo
    if [[ "${ok}" = y ]] ; then
      read feedPassword\?"Enter the password for the user ${feedUser}: "
    fi

    protocol=${feedURL%://*}
    hostANDport=${${feedURL#${protocol}://}%%/*}
    route=${feedURL#${protocol}://${hostANDport}}

    # ${urlWithCredentials} is used below only to try to obtain the feed title.
    urlWithCredentials=${protocol}://${feedUser}${feedPassword:+:${feedPassword}}@${hostANDport}/${route}
  fi

  titleParserXSL=$(makeParser /rss/channel/title)
  trap "${RM} -f ${titleParserXSL} ; exit ;" 0 1 2 3

  ##########################################################################################
  ## Get the feed title, either by its own XML (with xsltproc), or by
  ## brute force with (wget). This code snippet and the XSL parser
  ## snippet lifted from bashpodder, http://www.lincgeek.org/bashpodder/
  ## (link retrieved Tue Aug 9 11:27:36 CDT 2016)
  ##########################################################################################
  feedTitle=$(${XSLTPROC} ${titleParserXSL} "${urlWithCredentials:-${feedURL}}" 2>/dev/null ||
		 ${WGET} -q "${urlWithCredentials:-${feedURL}}" -O - | ${GREP} -m 1 '<title>' | ${SED} -e 's,^ *<title>\(.*\)</title>.*$,\1,')
  if [[ -z "${feedTitle}" ]] ; then

    # Try it without the username and password.
    if [[ -n "${urlWithCredentials}" ]] ; then

      feedTitle=$(${XSLTPROC} ${titleParserXSL} "${feedURL}" 2>/dev/null ||
		     ${WGET} -q "${feedURL}" -O - | ${GREP} -m 1 '<title>' | ${SED} -e 's,^ *<title>\(.*\)</title>.*$,\1,')

    else

      warning "I could not discern the title for this feed. Please make sure the URL, username (if needed) and password (if needed) are correct and if necessary, re-run ${myName}."

    fi
  fi

  ${RM} -f ${titleParserXSL}
  trap - 0 1 2 3

  ##########################################################################################
  ## Prompt for a name, use the feed title previously obtained if the
  ## user does not enter anything.
  ##########################################################################################
  read name\?"Enter a name for this podcast (${BOLD}Note: I may do some manipulation of the name${NORM}): ${feedTitle:+[${feedTitle}]} "
  [[ -z "${name}" ]] && name=${feedTitle}
  # From the inside out, this parameter substitution does the following:
  #    converts ":", "<Space>", ",", and "!" to a dash ("-")
  #    deletes single (') and double (") quotes
  #    converts double-dash ("--") to single dash ("-")
  #    deletes a single dash ("-") at the end of the string
  read -q ok\?"Using ${${${${name//[: ,\!)(]/-}//[\"\']/}//--/-}/%-/} for the podcast name. OK? [y,N]: "
  until [[ ${ok} = y ]] ; do

    echo
    read name\?"OK, try again. Enter a name for this podcast: "
    read -q ok\?"Using '${${${${name//[: ,\!)(]/-}//[\"\']/}//--/-}/%-/}' for the podcast name. OK? [y,N]: "

  done
  feedName="${${${${name//[: ,\!)(]/-}//[\"\']/}//--/-}/%-/}"

  ##########################################################################################
  ## Get the "category" for this podcast. Use a Rivendell GROUP for the category name.
  ##########################################################################################
  # See zsh-functions for the definition of doSQL.
  rivendellGroupList=$(doSQL "select NAME from GROUPS order by NAME")

  # List the groups and prompt them for a group to use if they asked for
  # a list or if they did not name a group.
  if [[ -z "${group}" ]] || [[ "${group}" =~ 'list' ]] ; then

    echo "\nCurrent list of GROUPs:"
    ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${rivendellGroupList}
    read group\?"Type the name of the Rivendell GROUP into which this podcast will be imported: "

  fi

  # Validate the group against the current known list of groups in the
  # Rivendell database.
  until ${GREP} -q "^${group}$" <<< ${rivendellGroupList} ; do

    warning "'${group}' is not in the list. Please use a valid GROUP name."

    echo "Current list of GROUPs:"
    ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${rivendellGroupList}
    read group\?"Enter the Rivendell GROUP into which this podcast will be imported: "

  done

  (( verbose )) && echo ${feedURL} ${group} ${feedName}${feedUser:+" USER:${feedUser}"}${feedPassword:+" PASS:${feedPassword}"}

  [[ -w ${DIR_CONFIG}/${CONFIG_SERVERLIST} ]] ||
    exit $(error "Missing access rights to modify the file ${DIR_CONFIG}/${CONFIG_SERVERLIST}")

  local tmpfile=$(mktemp)
  trap "${RM} -f ${tmpfile}; exit;" 0 1 2 3

  # Same group and name (possibly different URL?).
  if ${GREP} -P -q "^[^#].*\s+${group}\s+${feedName}\s+" ${DIR_CONFIG}/${CONFIG_SERVERLIST} ; then

    read -q ok\?"${feedName} already exists in group ${group}. Replace? [y,N] "
    if [[ "${ok}" = y ]] ; then

      ${GREP} -P -v "^[^#].*\s+${group}\s+${feedName}\s+" ${DIR_CONFIG}/${CONFIG_SERVERLIST} > ${tmpfile}

    fi

    # Same name, different group.
  elif ${GREP} -P -q "^[^#].*\s+${feedName}\s+" ${DIR_CONFIG}/${CONFIG_SERVERLIST} ; then

    read -q ok\?"${feedName} already exists in a different group. Change to group '${group}'? [y,N] "
    if [[ "${ok}" = y ]] ; then

      ${GREP} -P -v "^[^#].*\s+${feedName}\s+" ${DIR_CONFIG}/${CONFIG_SERVERLIST} > ${tmpfile}

    fi

    # New feed.
  else

    ${CP} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ${tmpfile} ||
      exit $(error "Could not make a copy of ${DIR_CONFIG}/${CONFIG_SERVERLIST} (${?}). Bailing out.")

    ${CAT} >> ${tmpfile} <<EOF
${feedURL} ${group} ${feedName}${feedUser:+" USER:${feedUser}"}${feedPassword:+" PASS:${feedPassword}"}
EOF

  fi

  if [[ -s ${tmpfile} ]] ; then

    # We made a tmpfile, so replace serverlist with its contents.
    ${MV} ${tmpfile} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ||
      exit $(error "Could not replace ${DIR_CONFIG}/${CONFIG_SERVERLIST}.")

    ${CHMOD} 644 ${DIR_CONFIG}/${CONFIG_SERVERLIST}

    ${MKDIR} -p ${DIR_LIBRARY}/${group}/${feedName} ||
      exit $(error "ERROR: failed to create new podcast directory ${DIR_LIBRARY}/${group}/${feedName}. (${?}).")

  fi

  cat <<EOF

Podcast added. Now set up a Rivendell dropbox, and paste the path

  ${BOLD}${DIR_LIBRARY}/${group}/${feedName}/*.mp3${NORM}

in the "Path Spec" field in rdadmin->Manage Hosts->HOST->Dropbox Configuration.

EOF

  trap - 0 1 2 3
}

enableFeed() {
  local myName=${1} ; shift
  local verbose=${1}

  local feedList feedName tmpfile

  feedList=$(${GREP} '^#DISABLED#' ${DIR_CONFIG}/${CONFIG_SERVERLIST} | ${AWK} '{print $3}')

  if (( $(wc -l <<<${feedList}) > 1 )) ; then

    echo "Current list of disabled podcast feeds:"
    ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
    read feedName\?"Type or paste the name of the podcast you want to enable (and press <Enter>): "

    until ${GREP} -q "^${feedName}$" <<< ${feedList} ; do

      warning "'${feedName}' is not in the list. Please use a valid feed name."

      echo "Current list of disabled podcast feeds:"
      ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
      read feedName\?"Type or paste the name of the podcast you want to enable: "

    done

  else

    # There is only one feed to enable, so do not bother prompting for it.
    feedName=${feedList}

  fi

  echo "Enabling '${feedName}' in the feed list... \c"

  trap "${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ; exit ;" 0 1 2 3

  ${SED} -i.bak -e "/^#DISABLED#.*[[:space:]]${feedName}[[:space:]]*/s/^#DISABLED#//" ${DIR_CONFIG}/${CONFIG_SERVERLIST}
  # The sed command *should* result in exactly one line of
  # difference between the original and the edited file.
  if (( $(${DIFF} --side-by-side --suppress-common-lines ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ${DIR_CONFIG}/${CONFIG_SERVERLIST} | wc -l) == 1 )) ; then

    ${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak
    echo "Done."

  else

    warning "Could not properly enable the disabled podcast feed '${feedName}'.
Please fix the file '${DIR_CONFIG}/${CONFIG_SERVERLIST}' manually."

    ${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak

  fi

  trap - 0 1 2 3
}

deleteFeed() {
  local myName=${1} ; shift
  local verbose=${1}

  local feedList feedName deleteOrDisable tmpfile

  feedList=$(${GREP} -v '^#' ${DIR_CONFIG}/${CONFIG_SERVERLIST} | ${AWK} '{print $3}')
  echo "Current list of podcast feeds:"
  ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
  read feedName\?"Type or paste the name of the podcast you want to delete or disable (and press <Enter>): "

  until ${GREP} -q "^${feedName}$" <<< ${feedList} ; do

    warning "'${feedName}' is not in the list. Please use a valid feed name."

    echo "Current list of podcast feeds:"
    ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
    read feedName\?"Type or paste the name of the podcast you want to delete or disable: "

  done

  read -k 1 deleteOrDisable\?"Do you want to disable (d) or delete (D) '${feedName}'? "
  until [[ "${deleteOrDisable}" =~ '[Dd]' ]] ; do
    echo
    read -k 1 deleteOrDisable\?"Please type a lower case 'd' for 'disable' or an upper case 'D' for 'delete' "
  done
  echo

  if [[ "${deleteOrDisable}" = 'd' ]] ; then

    echo "Disabling '${feedName}' in the feed list... \c"

    trap "${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ; exit ;" 0 1 2 3

    ${SED} -i.bak -e "/[[:space:]]${feedName}[[:space:]]*/s/^/#DISABLED#/" ${DIR_CONFIG}/${CONFIG_SERVERLIST}
    # The sed command *should* result in exactly one line of
    # difference between the original and the edited file.
    if (( $(${DIFF} --side-by-side --suppress-common-lines ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ${DIR_CONFIG}/${CONFIG_SERVERLIST} | wc -l) == 1 )) ; then

      ${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak
      echo "Done."

    else

      warning "Could not properly disable the podcast feed '${feedName}'. Please fix the file '${DIR_CONFIG}/${CONFIG_SERVERLIST}' manually."

      ${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak

    fi

    trap - 0 1 2 3

  elif [[ "${deleteOrDisable}" = 'D' ]] ; then

    echo "Deleting feed '${feedName}' from the feed list... \c"

    tmpfile=$(mktemp)
    trap "${RM} -f ${tmpfile}; exit;" 0 1 2 3

    ${GREP} -v "[[:space:]]${feedName}[[:space:]]*" ${DIR_CONFIG}/${CONFIG_SERVERLIST} > ${tmpfile}

    if [[ -s ${tmpfile} ]] ; then

      if ${MV} ${tmpfile} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ; then

	echo "Done."

      else

	warning "Could not replace '${DIR_CONFIG}/${CONFIG_SERVERLIST}' with the deleted podcast feed. Do you have the access rights to replace this file? Please fix the file '${DIR_CONFIG}/${CONFIG_SERVERLIST}' manually."

      fi
    else

      warning "Unable to find '${feedName}' in ${DIR_CONFIG}/${CONFIG_SERVERLIST}. Please fix the file ${DIR_CONFIG}/${CONFIG_SERVERLIST} manually."

    fi

  else

    echo "\nWTF? How did you get past the prompt without entering a 'd' or a 'D'?"

  fi

  trap - 0 1 2 3
}

listFeeds() {
  local myName=${1} ; shift
  local verbose=${1}

  local -x LESS='RCiP Viewing podcast feeds\. Enter <q> to quit\. <PgDown> and <PgUP> to scroll\.'

  (
    # The header.
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
    printf '%-46s %-16s %-48s\n'  "Title" "Group" "Credentials"
    printf '-%.0s' {1..46}; printf '-%.0s' {1..16}; printf '-%.0s' {1..48}; print

    # The content.
    ${SED} -e '1,/^# ---------/d' < ${DIR_CONFIG}/${CONFIG_SERVERLIST} |
      ${GREP} -v '^ *$' |
      while read url group title rest ; do
	if [[ ${url} =~ '#DISABLED#.*' ]] ; then
	  title="${RED}DISABLED:${NORM} ${title}"
	  url="${RED}DISABLED:${NORM} ${url/\#DISABLED#/}"
	fi
	printf '%-46s %-16s %-48s\n%-80s\n\n' ${title} ${group} ${rest:-""} ${url}
      done

    # The footer.
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
  ) | less
}

showLastStatus() {
  local myName=${1} ; shift
  local type=${1} ; shift
  local verbose=${1}

  local statusFile=${STATUS_FILE:-${ROOT:-/}var/tmp/pmw-podget-wrapper.${type}}

  case ${type} in
    out) OUTPUT="most recent podget output results" ;;
    err) OUTPUT="most recent podget error output" ;;
  esac
  local -x LESS="RCiP Viewing ${OUTPUT}\. Enter <q> to quit\. <PgDown> and <PgUP> to scroll\."

  (
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print

    ${CAT} ${statusFile}

    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
  ) | less
}

makeParser() {
  local selection=${1:?"Need an XML selection."}
  local tempfile=$(mktemp)
  
  ${CAT} > ${tempfile} <<EOF
<?xml version="1.0"?>
<stylesheet version="1.0"
	xmlns="http://www.w3.org/1999/XSL/Transform">
	<output method="text"/>
	<template match="/">
		<apply-templates select="${selection}"/>
	</template>
	<template match="enclosure">
		<value-of select="@url"/><text>&#10;</text>
	</template>
</stylesheet>
EOF

  echo ${tempfile}
}

warning() {
  local message=${1}

  ${CAT} <<EOF

${BOLD}${RED}WARNING:${NORM}
$(${FMT} -w 79 <<< ${message})

EOF
}

error() {
  local message=${1}

  ${CAT} <<EOF

${RED}${BOLD}ERROR:${NORM}
$(${FMT} -w 79 <<< ${message})

EOF
  echo 254
  return 254
}

##########################################################################################
## Script main line
##########################################################################################

# The shell commands we will use in this script.
typeset -a ourCommands
ourCommands=(
  awk
  cat
  chmod
  column
  cp
  diff
  fmt
  getopt
  grep
  mkdir
  mv
  podget
  rm
  sed
  wget
  xsltproc
)

# Find the executables we need; this uses a little old fashioned shell and
# a ZSH trick -- the (U) in the eval(1) says to evaluate the parameter as
# all upper case letters. We will use the command names in upper case as
# variables by which to call the commands later in this function.
for C in ${ourCommands} ; do
  for D in ${path} ; do
    [[ -x ${D}/${C} ]] && { eval ${(U)C}=${D}/${C} ; break }
  done
  [[ -x $(eval echo \$${(U)C}) ]] || { echo "Cannot find ${C}! Done."; return 1 }
done

# Set some defaults, and see below for more ways to set these.
DIR_CONFIG=%PODGET_DIR_CONFIG%
CONFIG_CORE=podgetrc
CONFIG_NOTIFY=notifyrc

TEMP=$(${GETOPT} -o c:Dd:Vvg:h --long config:,debug,dir-config:,version,verbose,group:,help -n "${0##*/}" -- "${@}")
if (( ${?} != 0 )) ; then echo "Terminating..." >&2 ; return 1 ; fi
# Note the quotes around ${TEMP}: they are essential!
eval set -- "${TEMP}"
while : ; do
  case "${1}" in
    -D|--debu*) DEBUG=1 ; shift ;;
    -c|--conf*) CONFIG_CORE=${2} ; shift 2 ;;
    -d|--dir-*) DIR_CONFIG=${2} ; shift 2 ;;
    -g|--grou*) group=${2} ; shift 2 ;;
    -h|--help*) usage ${0##*/} ; exit ;;
    -v|--verb*) VERBOSE=1 ; PASSFILE=none ; shift ;;
    -V|--vers*) showVersion=1 ; shift ;;
    --) shift ; break ;;
    *) echo "Internal error!" >&2 ; return 1 ;;
  esac
done

if ((showVersion)) ; then
  echo "${0##*/}: version ${vMajor}.${vMinor}.${vPatch}-${${vHash#\$Hash: }%$}"
  exit 0
fi

RED="${fg_bold[red]}"
BOLD="${bold_color}"
NORM="${reset_color}"

# Ensure the configuration directory exists.
if [[ ! -d ${DIR_CONFIG} ]] ; then
  if ! ${MKDIR} -p ${DIR_CONFIG} ; then

    ${CAT} <<EOF
${BOLD}${RED}
ERROR: unable to create configuration directory '${DIR_CONFIG}'. Make
sure your permissions are set so that you have file create and write
rights to the ${DIR_CONFIG} directory.

Cannot continue.
${NORM}
EOF
    exit 2

  fi
fi

# Run podget(1) if it appears it has never been run.
failCount=1
maxAttempts=10
until [[ -r ${DIR_CONFIG}/${CONFIG_CORE} ]] ; do

  warning "Unable to read configuration file ${DIR_CONFIG}/${CONFIG_CORE}. Running podget to create a new configuration..."

  ${PODGET} --dir_config ${DIR_CONFIG}

  ((failCount++ > maxAttempts )) &&
    exit $(error "Unable to create ${DIR_CONFIG}/${CONFIG_CORE} ${maxAttempts} times. I quit.")

done

[[ -r ${DIR_CONFIG}/${CONFIG_CORE} ]] && source ${DIR_CONFIG}/${CONFIG_CORE}
[[ -n "${CONFIG_SERVERLIST}" ]] ||
  error "Failed to get a setting for 'CONFIG_SERVERLIST'. Does '${DIR_CONFIG}/${CONFIG_CORE}' exist?"

##########################################################################################
## The guts of why we are here.
##########################################################################################

typeset -a menu command
typeset -R 2 count

while : ; do
    count=0

    menu=(
      "Quit"
      "Add or Replace a podcast feed"
      "Delete or disable a podcast feed"
      "Enable a disabled podcast feed"
      "Show the complete list of podcast feeds"
      "Show most recent podget run status"
      "Show most recent podget error status"
      "\[Advanced\] Edit the podcast list with '${EDITOR:-${VISUAL:-nano}}'"
      "\[Advanced\] Edit the notification configuration with '${EDITOR:-${VISUAL:-nano}}'"
    )
    command=(
      'addOrReplaceFeed ${0##*/} ${verbose}'
      'deleteFeed ${0##*/} ${verbose}'
      'enableFeed ${0##*/} ${verbose}'
      'listFeeds ${0##*/} ${verbose}'
      'showLastStatus ${0##*/} out ${verbose}'
      'showLastStatus ${0##*/} err ${verbose}'
      '${EDITOR:-${VISUAL:-nano}} ${DIR_CONFIG}/${CONFIG_SERVERLIST}'
      '${EDITOR:-${VISUAL:-nano}} ${DIR_CONFIG}/${CONFIG_NOTIFY}'
    )

    for menuItem in ${menu} ; do
	echo "${count}) $(eval echo ${menuItem})"
	(( count++ ))
    done
    echo

    read choice\?"Type your choice and press <Enter>: "

    echo

    if [[ -z "${choice}" ]] ; then
	echo "Please enter a number between 0 and $(( count - 1 ))."

    elif [[ ${choice} =~ '[0Qq]' ]] ; then
	exit

    elif [[ "${choice}" =~ '[[:space:]]*[[:alpha:]]+' ]] ; then
	echo "'${choice}' is not an option. Please enter a number between 0 and $(( count - 1 ))."

    elif [[ "${choice}" =~ '[[:space:]]*[[:alnum:]]+[[:space:]]+' ]] ; then
	echo "'${choice}' is not an option (watch your spaces). Please enter a number between 0 and $(( count - 1 ))."

    elif (( choice > 0 && choice < count )) ; then
	eval $(echo ${command[${choice}]})

    else
	echo "'${choice}' is not an option. Please enter a number between 0 and $(( count - 1 ))."

    fi

    echo

    read -q choice\?"Press any key to continue: "
    echo
done

exit

# Local Variables: ***
# mode:shell-script ***
# indent-tabs-mode: f ***
# sh-indentation: 2 ***
# sh-basic-offset: 2 ***
# sh-indent-for-do: 0 ***
# sh-indent-after-do: + ***
# sh-indent-comment: t ***
# sh-indent-after-case: + ***
# sh-indent-after-done: 0 ***
# sh-indent-after-else: + ***
# sh-indent-after-if: + ***
# sh-indent-after-loop-construct: + ***
# sh-indent-after-open: + ***
# sh-indent-after-switch: + ***
# sh-indent-for-case-alt: ++ ***
# sh-indent-for-case-label: + ***
# sh-indent-for-continuation: + ***
# sh-indent-for-done: 0 ***
# sh-indent-for-else: 0 ***
# sh-indent-for-fi: 0 ***
# sh-indent-for-then: 0 ***
# End: ***
