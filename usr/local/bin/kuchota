#!/bin/zsh

##########################################################################################
##########################################################################################
##
##
## kuchota (Swahili for "fetch")
##
## A PMW podget tool to manage podcast feeds (i.e., RSS, ATOM, etc.)
## and downloads by podget(1), for later import into a Rivendell
## library.
##
##########################################################################################
##########################################################################################

setopt REMATCH_PCRE
setopt NO_CASE_MATCH
zmodload zsh/regex
zmodload zsh/datetime
zmodload zsh/terminfo
autoload colors
colors

# This script complies with Semantic Versioning: http://semver.org/
vMajor=0
vMinor=1
vPatch=1
vHash='$Hash: 2d335f9$'

# Get zsh functions necessary for this script.
[[ -r ${ROOT:-/}usr/local/bin/zsh-functions ]] && source ${ROOT:-/}usr/local/bin/zsh-functions

##########################################################################################
## Locally defined subroutines
##########################################################################################

# How to use this command.
usage() {
  myName=${1}

  ${CAT} << EOF
${myName}: add a new RSS feed to the list of podcasts.

Summary: ${myName##*/} [ --verbose (-v) ] [ --debug (-D) ] [ --version (-V) ]
                       [ --config (-c) <podget_configuration_file> ]
                       [ --dir_config (-d) <podget_configuration_directory> ]
                       [ --group (-g) { <Rivendell Group Name> or 'list' } ]

You may use the word "list" for the --group (-g) option.
This will cause ${myName##*/} to list the available groups and
prompt you for which one to use for this podcast.

EOF
}

addOrReplaceFeed() {
  local myName=${1} ; shift
  local verbose=${1}

  local feedURL feedUser feedPassword protocol hostANDport route urlWithCredentials titleParserXSL
  local feedTitle name group rivendellGroupList
  local ok

  trap 'trap - ; return ;' 0 1 2 3

  read feedURL\?"Type or paste the RSS feed URL for this podcast: "

  read -q ok\?"Does this podcast download require a username? [y,N] "
  echo
  if [[ "${ok}" = y ]] ; then
    read feedUser\?"Enter the feed username: "

    read -q ok\?"Does this URL require a password for the user ${feedUser}? [y,N] "
    echo
    if [[ "${ok}" = y ]] ; then
      read feedPassword\?"Enter the password for the user ${feedUser}: "
    fi

    protocol=${feedURL%://*}
    hostANDport=${${feedURL#${protocol}://}%%/*}
    route=${feedURL#${protocol}://${hostANDport}}

    # ${urlWithCredentials} is used below only to try to obtain the feed title.
    urlWithCredentials=${protocol}://${feedUser}${feedPassword:+:${feedPassword}}@${hostANDport}/${route}
  fi

  titleParserXSL=$(makeParser /rss/channel/title)
  trap "${RM} -f ${titleParserXSL} ; trap - ; return ;" 0 1 2 3

  ##########################################################################################
  ## Get the feed title, either by its own XML (with xsltproc), or by
  ## brute force with (wget). This code snippet and the XSL parser
  ## snippet lifted from bashpodder, http://www.lincgeek.org/bashpodder/
  ## (link retrieved Tue Aug 9 11:27:36 CDT 2016)
  ##########################################################################################
  feedTitle=$(${XSLTPROC} ${titleParserXSL} "${urlWithCredentials:-${feedURL}}" 2>/dev/null ||
		 ${WGET} -q "${urlWithCredentials:-${feedURL}}" -O - | ${GREP} -m 1 '<title>' | ${SED} -e 's,^ *<title>\(.*\)</title>.*$,\1,')
  if [[ -z "${feedTitle}" ]] ; then

    # Try it without the username and password.
    if [[ -n "${urlWithCredentials}" ]] ; then

      feedTitle=$(${XSLTPROC} ${titleParserXSL} "${feedURL}" 2>/dev/null ||
		     ${WGET} -q "${feedURL}" -O - | ${GREP} -m 1 '<title>' | ${SED} -e 's,^ *<title>\(.*\)</title>.*$,\1,')

    else

      warning "I could not discern the title for this feed. Please make sure the URL, username (if needed) and password (if needed) are correct and if necessary, re-run ${myName}."

    fi
  fi

  ${RM} -f ${titleParserXSL}
  trap 'trap - ; return ;' 0 1 2 3

  ##########################################################################################
  ## Prompt for a name, use the feed title previously obtained if the
  ## user does not enter anything.
  ##########################################################################################
  read name\?"Enter a name for this podcast (${BOLD}Note: I may do some manipulation of the name${NORM}): ${feedTitle:+[${feedTitle}]} "
  [[ -z "${name}" ]] && name=${feedTitle}
  # From the inside out, this parameter substitution does the following:
  #    converts ":", "<Space>", ",", and "!" to a dash ("-")
  #    deletes single (') and double (") quotes
  #    converts double-dash ("--") to single dash ("-")
  #    deletes a single dash ("-") at the end of the string
  read -q ok\?"Using ${${${${name//[: ,\!)(]/-}//[\"\']/}//--/-}/%-/} for the podcast name. OK? [y,N]: "
  until [[ ${ok} = y ]] ; do

    echo
    read name\?"OK, try again. Enter a name for this podcast: "
    read -q ok\?"Using '${${${${name//[: ,\!)(]/-}//[\"\']/}//--/-}/%-/}' for the podcast name. OK? [y,N]: "

  done
  feedName="${${${${name//[: ,\!)(]/-}//[\"\']/}//--/-}/%-/}"

  ##########################################################################################
  ## Get the "category" for this podcast. Use a Rivendell GROUP for the category name.
  ##########################################################################################
  # See zsh-functions for the definition of doSQL.
  rivendellGroupList=$(doSQL "select NAME from GROUPS order by NAME")

  # List the groups and prompt them for a group to use if they asked for
  # a list or if they did not name a group.
  if [[ -z "${group}" ]] || [[ "${group}" =~ 'list' ]] ; then

    echo "\nCurrent list of GROUPs:"
    ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${rivendellGroupList}
    read group\?"Type the name of the Rivendell GROUP into which this podcast will be imported: "

  fi

  # Validate the group against the current known list of groups in the
  # Rivendell database.
  until ${GREP} -q "^${group}$" <<< ${rivendellGroupList} ; do

    warning "'${group}' is not in the list. Please use a valid GROUP name."

    echo "Current list of GROUPs:"
    ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${rivendellGroupList}
    read group\?"Enter the Rivendell GROUP into which this podcast will be imported: "

  done

  (( verbose )) && echo ${feedURL} ${group} ${feedName}${feedUser:+" USER:${feedUser}"}${feedPassword:+" PASS:${feedPassword}"}

  [[ -w ${DIR_CONFIG}/${CONFIG_SERVERLIST} ]] ||
    exit $(error "Missing access rights to modify the file ${DIR_CONFIG}/${CONFIG_SERVERLIST}")

  local tmpfile=$(mktemp)
  trap "${RM} -f ${tmpfile}; trap - ; return ;" 0 1 2 3

  # Same group and name (possibly different URL?).
  if ${GREP} -P -q "^[^#].*\s+${group}\s+${feedName}\s+" ${DIR_CONFIG}/${CONFIG_SERVERLIST} ; then

    read -q ok\?"${feedName} already exists in group ${group}. Replace? [y,N] "
    if [[ "${ok}" = y ]] ; then

      ${GREP} -P -v "^[^#].*\s+${group}\s+${feedName}\s+" ${DIR_CONFIG}/${CONFIG_SERVERLIST} > ${tmpfile}

    fi

    # Same name, different group.
  elif ${GREP} -P -q "^[^#].*\s+${feedName}\s+" ${DIR_CONFIG}/${CONFIG_SERVERLIST} ; then

    read -q ok\?"${feedName} already exists in a different group. Change to group '${group}'? [y,N] "
    if [[ "${ok}" = y ]] ; then

      ${GREP} -P -v "^[^#].*\s+${feedName}\s+" ${DIR_CONFIG}/${CONFIG_SERVERLIST} > ${tmpfile}

    fi

    # New feed.
  else

    ${CP} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ${tmpfile} ||
      exit $(error "Could not make a copy of ${DIR_CONFIG}/${CONFIG_SERVERLIST} (${?}). Bailing out.")

    ${CAT} >> ${tmpfile} <<EOF
${feedURL} ${group} ${feedName}${feedUser:+" USER:${feedUser}"}${feedPassword:+" PASS:${feedPassword}"}
EOF

  fi

  if [[ -s ${tmpfile} ]] ; then

    # We made a tmpfile, so replace serverlist with its contents.
    ${MV} ${tmpfile} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ||
      exit $(error "Could not replace ${DIR_CONFIG}/${CONFIG_SERVERLIST}.")

    ${CHMOD} 644 ${DIR_CONFIG}/${CONFIG_SERVERLIST}

    ${MKDIR} -p ${DIR_LIBRARY}/${group}/${feedName} ||
      exit $(error "ERROR: failed to create new podcast directory ${DIR_LIBRARY}/${group}/${feedName}. (${?}).")

  fi

  cat <<EOF

Podcast added. Now set up a Rivendell dropbox, and paste the path

  ${BOLD}${DIR_LIBRARY}/${group}/${feedName}/*.mp3${NORM}

in the "Path Spec" field in rdadmin->Manage Hosts->HOST->Dropbox Configuration.

EOF

  read ok\?"Press <Enter> to continue. "

  trap -
}

enableFeed() {
  local myName=${1} ; shift
  local verbose=${1}

  local feedList feedNameEntered feedName tmpfile

  trap 'trap - 0 1 2 3 ; return ;' 0 1 2 3

  feedList=$(${GREP} '^#DISABLED#' ${DIR_CONFIG}/${CONFIG_SERVERLIST} | ${AWK} '{print $3}')

  # Try to enable feeds only if there actually are any disabled ones.
  if [[ -n "${feedList}" ]] ; then

    if (( $(wc -l <<<${feedList}) > 1 )) ; then

      echo "Current list of disabled podcast feeds:"
      ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
      read feedNameEntered\?"Enter the name of the podcast ('*' wildcard OK) you want to enable (and press <Enter>): "

      # Allow '*'-style wildcards in the feedName, will expand it below.
      until feedName=$(${GREP} "^${feedNameEntered//\*/.*}$" <<< ${feedList}) ; do

	warning "'${feedNameEntered}' is not in the list. Please use a valid feed name."

	echo "Current list of disabled podcast feeds:"
	${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
	read feedNameEntered\?"Type or paste the name of the podcast ('*' wildcard OK) you want to enable: "

      done

    else

      # There is only one feed to enable, so do not bother prompting for it.
      feedName=${feedList}

    fi

    echo "Enabling '${feedName}' in the feed list... \c"

    trap "${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ; trap - ; return ;" 0 1 2 3

    ${SED} -i.bak -e "/^#DISABLED#.*[[:space:]]${feedName}[[:space:]]*/s/^#DISABLED#//" ${DIR_CONFIG}/${CONFIG_SERVERLIST}
    # The sed command *should* result in exactly one line of
    # difference between the original and the edited file.
    if (( $(${DIFF} --side-by-side --suppress-common-lines ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ${DIR_CONFIG}/${CONFIG_SERVERLIST} | wc -l) == 1 )) ; then

      ${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak
      echo "Done."

    else

      warning "Could not properly enable the disabled podcast feed '${feedName}'.
Please fix the file '${DIR_CONFIG}/${CONFIG_SERVERLIST}' manually."

      ${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak

    fi

    read ok\?"Press <Enter> to continue. "

  else

    read ok\?"There are no disabled feeds available. Press <Enter> to continue. "

  fi

  trap -
}

deleteFeed() {
  local myName=${1} ; shift
  local verbose=${1}

  local feedList feedNameEntered feedName deleteOrDisable tmpfile

  trap 'trap - ; return ;' 0 1 2 3

  feedList=$(${GREP} -v '^#' ${DIR_CONFIG}/${CONFIG_SERVERLIST} | ${AWK} '{print $3}')

  # Delete feeds only if there actually are any available.
  if [[ -n "${feedList}" ]] ; then

    # Prompt for a feed to delete only if there is more than one in
    # the list.
    if (( $(wc -l <<<${feedList}) > 1 )) ; then

      echo "Current list of podcast feeds:"
      ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
      read feedNameEntered\?"Enter the name of the podcast ('*' wildcard OK) you want to delete or disable (and press <Enter>): "

      until feedName=$(${GREP} "^${feedNameEntered//\*/.*}$" <<< ${feedList}) ; do

	warning "'${feedNameEntered}' is not in the list. Please use a valid feed name."

	echo "Current list of podcast feeds:"
	${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
	read feedNameEntered\?"Enter the name of the podcast ('*' wildcard OK) you want to delete or disable: "

      done

    else

      # Only one feed, so offer it for deletion.
      feedName=${feedList}

    fi

    read -k 1 deleteOrDisable\?"Do you want to disable (d) or delete (D) '${feedName}'? "
    until [[ "${deleteOrDisable}" =~ '[Dd]' ]] ; do
      echo
      read -k 1 deleteOrDisable\?"Please type a lower case 'd' for 'disable' or an upper case 'D' for 'delete' "
    done
    echo

    if [[ "${deleteOrDisable}" = 'd' ]] ; then

      echo "Disabling '${feedName}' in the feed list... \c"

      trap "${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ; trap - ; return ;" 0 1 2 3

      ${SED} -i.bak -e "/[[:space:]]${feedName}[[:space:]]*/s/^/#DISABLED#/" ${DIR_CONFIG}/${CONFIG_SERVERLIST}
      # The sed command *should* result in exactly one line of
      # difference between the original and the edited file.
      if (( $(${DIFF} --side-by-side --suppress-common-lines ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ${DIR_CONFIG}/${CONFIG_SERVERLIST} | wc -l) == 1 )) ; then

	${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak
	echo "Done."

      else

	warning "Could not properly disable the podcast feed '${feedName}'. Please fix the file '${DIR_CONFIG}/${CONFIG_SERVERLIST}' manually."

	${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak

      fi

      trap 'trap - ; return ;' 0 1 2 3

    elif [[ "${deleteOrDisable}" = 'D' ]] ; then

      echo "Deleting feed '${feedName}' from the feed list... \c"

      tmpfile=$(mktemp)
      trap "${RM} -f ${tmpfile}; trap - ; return ;" 0 1 2 3

      ${GREP} -v "[[:space:]]${feedName}[[:space:]]*" ${DIR_CONFIG}/${CONFIG_SERVERLIST} > ${tmpfile}

      if [[ -s ${tmpfile} ]] ; then

	if ${MV} ${tmpfile} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ; then

	  echo "Done."

	else

	  warning "Could not replace '${DIR_CONFIG}/${CONFIG_SERVERLIST}' with the deleted podcast feed. Do you have the access rights to replace this file? Please fix the file '${DIR_CONFIG}/${CONFIG_SERVERLIST}' manually."

	fi
      else

	warning "Unable to find '${feedName}' in ${DIR_CONFIG}/${CONFIG_SERVERLIST}. Please fix the file ${DIR_CONFIG}/${CONFIG_SERVERLIST} manually."

      fi

    else

      echo "\nWTF? How did you get past the prompt without entering a 'd' or a 'D'?"

    fi

    trap 'trap - ; return ;' 0 1 2 3

    read ok\?"Press <Enter> to continue. "

  else

    read ok\?"There are no feeds available to delete. Press <Enter> to continue. "

  fi

  trap -
}

listFeeds() {
  local myName=${1} ; shift
  local verbose=${1}

  local -x LESS='RCiP Viewing podcast feeds?e (End of Output).\. Enter <q> to quit\. <PgDown> and <PgUP> to scroll\.'

  trap 'trap - ; return ;' 0 1 2 3

  (
    # The header.
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
    printf '%-46s %-16s %-48s\n'  "Title" "Group" "Credentials"
    printf '-%.0s' {1..46}; printf '-%.0s' {1..16}; printf '-%.0s' {1..48}; print

    # The content.
    ${SED} -e '1,/^# ---------/d' < ${DIR_CONFIG}/${CONFIG_SERVERLIST} |
      ${GREP} -v '^ *$' |
      while read url group title rest ; do
	if [[ ${url} =~ '#DISABLED#.*' ]] ; then
	  title="${RED}DISABLED:${NORM} ${title}"
	  url="${RED}DISABLED:${NORM} ${url/\#DISABLED#/}"
	fi
	rdDropBoxPath="${DIR_LIBRARY}/${group}/${title}/*.mp3"
	printf '%-46s %-16s %-48s\n%-80s\nRD DropBox: %-80s\n\n' ${title} ${group} ${rest:-""} ${url} "${rdDropBoxPath//${RED}DISABLED:${NORM} }"
      done

    # The footer.
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
  ) | less

  trap -
}

showLastStatus() {
  local myName=${1} ; shift
  local type=${1} ; shift
  local verbose=${1}

  local statusFile=${STATUS_FILE:-${ROOT:-/}var/tmp/pmw-podget-wrapper.${type}}

  trap 'trap - ; return ;' 0 1 2 3

  case ${type} in
    out) OUTPUT="output results" ;;
    err) OUTPUT="error output" ;;
  esac
  local -x LESS="RCiP Viewing the latest podget ${OUTPUT}?e (End of Output).\. Enter <q> to quit\. <PgDown> and <PgUP> to scroll\."

  (
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print

    ${CAT} ${statusFile}

    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
  ) | less

  trap -
}

editSchedule() {
  local myName=${1} ; shift
  local verbose=${1}

  local minute oMinute hour oHour crontab answer ok

  trap 'trap - ; return ;' 0 1 2 3

  # Snag the current crontab for later processing.
  crontab=$(${CRONTAB} -l)

  # Give them the opportunity to change the existing schedule.
  if ${GREP} -q 'pmw-podget-wrapper' <<<"${crontab:-X}" ; then

  ${CAT} <<EOF

The current schedule for downloading podcasts is as follows. This is
the entire crontab entry. '${BOLD}pmw-podget-wraper${NORM}' is the tool used to
launch and track '${BOLD}podget${NORM}', the downloader app.

${BOLD}$(${GREP} 'podget-wrapper' <<<${crontab})${NORM}

EOF

  read -q change\?"Do you want to change the schedule? [y,N] "
  case ${change} in
    [Nn]) echo "Leaving the download schedule as it is." ; trap - ; return ;;
  esac

  # Pre-fill the vailues we will later prompt for.
  minute=$(${GREP} '^[^#].*podget-wrapper' <<<${crontab} | ${AWK} '{print $1}')
  hour=$(${GREP} '^[^#].*podget-wrapper' <<<${crontab} | ${AWK} '{print $2}')

  fi

  ${CAT} <<EOF


${(C)myName} runs the 'pmw-podget-wrapper' backend periodically in
order to check for new episodes of podcasts. I check all podcasts
each time, downloading new episodes for each podcast as they appear.

Typically, 'pmw-podget-wrapper' runs from cron at least once an hour
every day. I'll assume you want to do that. You will need to update
the cron job manually (using the 'crontab' command) only if you want a
different schedule.

Valid hours are 0 - 23 and '*'.

EOF

  until [[ "${ok}" =~ '[Yy]' ]] ; do

    oHour=${hour}
    read hour\?"Type the hour(s) you want ${myName} to check for new podcasts (enter '*' for every hour): ${hour:+'[${hour}] '}"
    [[ -z "${hour}" ]] && hour=${oHour}
    until [[ "${hour}" =~ '^(\*|[[:digit:],]+)$' ]] ; do

      echo "You need to enter either an asterisk ('*'), or some combination of hour numbers and commas."
      read hour\?"Type the hour(s) you want ${myName} to check for new podcasts (enter '*' for every hour): "

    done

    ${CAT} <<EOF

Now I need to know how many times an hour you want to check for new
podcasts. You can enter a single "minute" representing once an hour,
or you can enter multiple minutes separated with commas (','). Valid
minutes are 0 - 59.

EOF

    oMinute=${minute}
    read minute\?"Enter the minute(s) of the hour(s) ('${hour}') you want to check for podcasts: ${minute:+'[${minute}] '}"
    [[ -z "${minute}" ]] && minute=${oMinute}
    until [[ "${minute}" =~ '^[[:digit:],]+$' ]] ; do

      echo "You need to enter combination of minute numbers and commas."
      read minute\?"Type the minute(s) of the hour(s) ('${hour}') you want to check for podcasts: "

    done

    echo "Using 'hour: ${hour}' and 'minute: ${minute}' for the podcast download schedule."
    read -q ok\?"OK to commit this schedule? [y,N]"
    echo

  done

  (
    echo ${crontab} | ${GREP} -v 'pmw-podget-wrapper'
    echo "${minute} ${hour} * * * zsh /usr/local/bin/pmw-podget-wrapper" 
  ) | ${CRONTAB} -

  ${CAT} <<EOF

Here is the complete cron entry for downloading podcasts:

$(${CRONTAB} -l | ${GREP} --perl-regexp '^(#|.*podget-wrapper)')

EOF

  trap -
}

editFile() {
  local myName=${1} ; shift
  local filename=${1} ; shift
  local verbose=${1}

  trap 'trap - ; return ;' 0 1 2 3

  ${VISUAL:-${EDITOR:-nano}} ${filename}

  trap -
}

cronEdit() {
  local myName=${1} ; shift
  local verbose=${1}

  trap 'trap - ; return ;' 0 1 2 3

  EDITOR=${VISUAL:-${EDITOR:-nano}} ${CRONTAB} -e

  trap -
}

makeParser() {
  local selection=${1:?"Need an XML selection."}
  local tempfile=$(mktemp)
  
  ${CAT} > ${tempfile} <<EOF
<?xml version="1.0"?>
<stylesheet version="1.0"
	xmlns="http://www.w3.org/1999/XSL/Transform">
	<output method="text"/>
	<template match="/">
		<apply-templates select="${selection}"/>
	</template>
	<template match="enclosure">
		<value-of select="@url"/><text>&#10;</text>
	</template>
</stylesheet>
EOF

  echo ${tempfile}
}

warning() {
  local message=${1}

  ${CAT} <<EOF

${BOLD}${RED}WARNING:${NORM}
$(${FMT} -w 79 <<< ${message})

EOF
}

error() {
  local message=${1}

  ${CAT} <<EOF

${RED}${BOLD}ERROR:${NORM}
$(${FMT} -w 79 <<< ${message})

EOF
  echo 254
  return 254
}

##########################################################################################
## Script main line
##########################################################################################

# The shell commands we will use in this script.
typeset -a ourCommands
ourCommands=(
  awk
  cat
  chmod
  column
  cp
  crontab
  diff
  fmt
  getopt
  grep
  mkdir
  mv
  podget
  rm
  sed
  wget
  xsltproc
)

# Find the executables we need; this uses a little old fashioned shell and
# a ZSH trick -- the (U) in the eval(1) says to evaluate the parameter as
# all upper case letters. We will use the command names in upper case as
# variables by which to call the commands later in this function.
for C in ${ourCommands} ; do
  for D in ${path} ; do
    [[ -x ${D}/${C} ]] && { eval ${(U)C}=${D}/${C} ; break }
  done
  [[ -x $(eval echo \$${(U)C}) ]] || { echo "Cannot find ${C}! Done."; return 1 }
done

# Set some defaults, and see below for more ways to set these.
DIR_CONFIG=%PODGET_DIR_CONFIG%
CONFIG_CORE=podgetrc
CONFIG_NOTIFY=notifyrc

TEMP=$(${GETOPT} -o c:Dd:Vvg:h --long config:,debug,dir-config:,version,verbose,group:,help -n "${0##*/}" -- "${@}")
if (( ${?} != 0 )) ; then echo "Terminating..." >&2 ; return 1 ; fi
# Note the quotes around ${TEMP}: they are essential!
eval set -- "${TEMP}"
while : ; do
  case "${1}" in
    -D|--debu*) DEBUG=1 ; shift ;;
    -c|--conf*) CONFIG_CORE=${2} ; shift 2 ;;
    -d|--dir-*) DIR_CONFIG=${2} ; shift 2 ;;
    -g|--grou*) group=${2} ; shift 2 ;;
    -h|--help*) usage ${0##*/} ; exit ;;
    -v|--verb*) VERBOSE=1 ; PASSFILE=none ; shift ;;
    -V|--vers*) showVersion=1 ; shift ;;
    --) shift ; break ;;
    *) echo "Internal error!" >&2 ; return 1 ;;
  esac
done

if ((showVersion)) ; then
  echo "${0##*/}: version ${vMajor}.${vMinor}.${vPatch}-${${vHash#\$Hash: }%$}"
  exit 0
fi

RED="${fg_bold[red]}"
BOLD="${bold_color}"
NORM="${reset_color}"

# Ensure the configuration directory exists.
if [[ ! -d ${DIR_CONFIG} ]] ; then
  if ! ${MKDIR} -p ${DIR_CONFIG} ; then

    ${CAT} <<EOF
${BOLD}${RED}
ERROR: unable to create configuration directory '${DIR_CONFIG}'. Make
sure your permissions are set so that you have file create and write
rights to the ${DIR_CONFIG} directory.

Cannot continue.
${NORM}
EOF
    exit 2

  fi
fi

# Run podget(1) if it appears it has never been run.
failCount=1
maxAttempts=10
until [[ -r ${DIR_CONFIG}/${CONFIG_CORE} ]] ; do

  warning "Unable to read configuration file ${DIR_CONFIG}/${CONFIG_CORE}. Running podget to create a new configuration..."

  ${PODGET} --dir_config ${DIR_CONFIG}

  ((failCount++ > maxAttempts )) &&
    exit $(error "Unable to create ${DIR_CONFIG}/${CONFIG_CORE} ${maxAttempts} times. I quit.")

done

[[ -r ${DIR_CONFIG}/${CONFIG_CORE} ]] && source ${DIR_CONFIG}/${CONFIG_CORE}
[[ -n "${CONFIG_SERVERLIST}" ]] ||
  error "Failed to get a setting for 'CONFIG_SERVERLIST'. Does '${DIR_CONFIG}/${CONFIG_CORE}' exist?"

##########################################################################################
## The guts of why we are here.
##########################################################################################

typeset -a menu command
typeset -R 2 count

while : ; do
    count=0

    menu=(
      "Quit"
      "Add or Replace a podcast feed"
      "Delete or disable a podcast feed"
      "Enable a disabled podcast feed"
      "Show the complete list of podcast feeds"
      "Show most recent podget run status"
      "Show most recent podget error status"
      "View and set the podget run schedule \(crontab\)"
      "\[Advanced\] Edit the podcast list with '${EDITOR:-${VISUAL:-nano}}'"
      "\[Advanced\] Edit the notification configuration with '${EDITOR:-${VISUAL:-nano}}'"
      "\[Advanced\] Edit ${USER}\'s crontab file"
    )
    command=(
      'addOrReplaceFeed ${0##*/} ${verbose}'
      'deleteFeed ${0##*/} ${verbose}'
      'enableFeed ${0##*/} ${verbose}'
      'listFeeds ${0##*/} ${verbose}'
      'showLastStatus ${0##*/} out ${verbose}'
      'showLastStatus ${0##*/} err ${verbose}'
      'editSchedule ${0##*/} ${verbose}'
      'editFile ${0##*/} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ${verbose}'
      'editFile ${0##*/} ${DIR_CONFIG}/${CONFIG_NOTIFY} ${verbose}'
      'cronEdit ${0##*/} ${verbose}'
    )
    windowTitle=(
      "Add Feed"
      "Delete Feed"
      "Enable Feed"
      "List Feeds"
      "Show Run Status"
      "Show Error Status"
      "Edit run Schedule"
      "Edit serverlist"
      "Edit notifyrc"
      "Edit crontab"
    )

    # Set the window title.
    printf '\033]0;%s\007' Kuchota

    for menuItem in ${menu} ; do
	echo "${count}) $(eval echo ${menuItem})"
	(( count++ ))
    done
    echo

    read choice\?"Type your choice and press <Enter>: "

    echo

    if [[ -z "${choice}" ]] ; then
      echo "Please enter a number between 0 and $(( count - 1 ))."

    elif [[ ${choice} =~ '^[0Qq]$' ]] ; then
      exit

    elif [[ "${choice}" =~ '[[:space:]]*[[:alpha:]]+' ]] ; then
      echo "'${choice}' is not an option. Please enter a number between 0 and $(( count - 1 ))."

    elif [[ "${choice}" =~ '[[:space:]]*[[:alnum:]]+[[:space:]]+' ]] ; then
      echo "'${choice}' is not an option (watch your spaces). Please enter a number between 0 and $(( count - 1 ))."

    elif (( choice > 0 && choice < count )) ; then

      # Set the window title for this menu choice then run the command.
      printf '\033]0;%s\007' ${windoTitle[${choice}]}
      eval $(echo ${command[${choice}]})

    else
	echo "'${choice}' is not an option. Please enter a number between 0 and $(( count - 1 ))."

    fi

    # As found in ZSH module zsh/terminfo.
    echoti clear
done

exit

# Local Variables: ***
# mode:shell-script ***
# indent-tabs-mode: f ***
# sh-indentation: 2 ***
# sh-basic-offset: 2 ***
# sh-indent-for-do: 0 ***
# sh-indent-after-do: + ***
# sh-indent-comment: t ***
# sh-indent-after-case: + ***
# sh-indent-after-done: 0 ***
# sh-indent-after-else: + ***
# sh-indent-after-if: + ***
# sh-indent-after-loop-construct: + ***
# sh-indent-after-open: + ***
# sh-indent-after-switch: + ***
# sh-indent-for-case-alt: ++ ***
# sh-indent-for-case-label: + ***
# sh-indent-for-continuation: + ***
# sh-indent-for-done: 0 ***
# sh-indent-for-else: 0 ***
# sh-indent-for-fi: 0 ***
# sh-indent-for-then: 0 ***
# End: ***
