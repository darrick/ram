#!/bin/zsh

##########################################################################################
##########################################################################################
##
##
## kuchota (Swahili for "fetch")
##
## A PMW podget tool to manage podcast feeds (i.e., RSS, ATOM, etc.)
## and downloads by podget(1), for later import into a Rivendell
## library.
##
##########################################################################################
##########################################################################################

setopt REMATCH_PCRE
setopt NO_CASE_MATCH
zmodload zsh/regex
zmodload zsh/datetime
zmodload zsh/terminfo
autoload colors
colors

# This script complies with Semantic Versioning: http://semver.org/
vMajor=0
vMinor=1
vPatch=2
vHash='$Hash$'

# Get zsh functions necessary for this script.
[[ -r ${ROOT:-/}usr/local/bin/zsh-functions ]] && source ${ROOT:-/}usr/local/bin/zsh-functions

##########################################################################################
## Locally defined subroutines
##########################################################################################

# How to use this command.
usage() {
  myName=${1}

  ${CAT} << EOF
${myName}: add a new RSS feed to the list of podcasts.

Summary: ${myName##*/} [ --verbose (-v) ] [ --debug (-D) ] [ --version (-V) ]
                       [ --config (-c) <podget_configuration_file> ]
                       [ --dir_config (-d) <podget_configuration_directory> ]
                       [ --group (-g) { <Rivendell Group Name> or 'list' } ]

You may use the word "list" for the --group (-g) option.
This will cause ${myName##*/} to list the available groups and
prompt you for which one to use for this podcast.

EOF
}

addOrReplaceFeed() {
  local myName=${1} ; shift
  local verbose=${1}

  local feedURL feedUser feedPassword protocol hostANDport route urlWithCredentials titleParserXSL
  local feedTitle name group rivendellGroupList
  local backupServerlist=${ROOT:-/}var/tmp/${CONFIG_SERVERLIST##*/}
  local replaceFeed=0 addNewFeed=1
  local ok

  trap 'trap - ; return ;' 0 1 2 3

  # Make a backup copy of serverlist before we make any changes.
  ${CP} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ${backupServerlist}

  read feedURL\?"Type or paste the RSS feed URL for this podcast: "

  read -q ok\?"Does this podcast download require a username? [y,N] "
  echo
  if [[ "${ok}" = y ]] ; then
    read feedUser\?"Enter the feed username: "

    read -q ok\?"Does this URL require a password for the user ${feedUser}? [y,N] "
    echo
    if [[ "${ok}" = y ]] ; then
      read feedPassword\?"Enter the password for the user ${feedUser}: "
    fi

    protocol=${feedURL%://*}
    hostANDport=${${feedURL#${protocol}://}%%/*}
    route=${feedURL#${protocol}://${hostANDport}}

    # ${urlWithCredentials} is used below only to try to obtain the feed title.
    urlWithCredentials=${protocol}://${feedUser}${feedPassword:+:${feedPassword}}@${hostANDport}/${route}
  fi

  titleParserXSL=$(makeParser /rss/channel/title)
  trap "${RM} -f ${titleParserXSL} ; trap - ; return ;" 0 1 2 3

  ##########################################################################################
  ## Get the feed title, either by its own XML (with xsltproc), or by
  ## brute force with (wget). This code snippet and the XSL parser
  ## snippet lifted from bashpodder, http://www.lincgeek.org/bashpodder/
  ## (link retrieved Tue Aug 9 11:27:36 CDT 2016)
  ##########################################################################################
  feedTitle=$(${XSLTPROC} ${titleParserXSL} "${urlWithCredentials:-${feedURL}}" 2>/dev/null ||
		 ${WGET} -q "${urlWithCredentials:-${feedURL}}" -O - | ${GREP} -m 1 '<title>' | ${SED} -e 's,^ *<title>\(.*\)</title>.*$,\1,')
  if [[ -z "${feedTitle}" ]] ; then

    # Try it without the username and password.
    if [[ -n "${urlWithCredentials}" ]] ; then

      feedTitle=$(${XSLTPROC} ${titleParserXSL} "${feedURL}" 2>/dev/null ||
		     ${WGET} -q "${feedURL}" -O - | ${GREP} -m 1 '<title>' | ${SED} -e 's,^ *<title>\(.*\)</title>.*$,\1,')

    else

      warning "I could not discern the title for this feed. Please make sure the URL, username (if needed) and password (if needed) are correct and if necessary, re-run ${myName}."

    fi
  fi

  ${RM} -f ${titleParserXSL}
  trap 'trap - ; return ;' 0 1 2 3

  ##########################################################################################
  ## Prompt for a name, use the feed title previously obtained if the
  ## user does not enter anything.
  ##########################################################################################
  read name\?"Enter a name for this podcast (${BOLD}Note: I may do some manipulation of the name${NORM}): ${feedTitle:+[${feedTitle}]} "
  [[ -z "${name}" ]] && name=${feedTitle}
  # From the inside out, this parameter substitution does the following:
  #    converts ":", "<Space>", ",", and "!" to a dash ("-")
  #    deletes single (') and double (") quotes
  #    converts double-dash ("--") to single dash ("-")
  #    deletes a single dash ("-") at the end of the string
  read -q ok\?"Using ${${${${name//[: ,\!)(]/-}//[\"\']/}//--/-}/%-/} for the podcast name. OK? [y,N]: "
  until [[ ${ok} = y ]] ; do

    echo
    read name\?"OK, try again. Enter a name for this podcast: "
    read -q ok\?"Using '${${${${name//[: ,\!)(]/-}//[\"\']/}//--/-}/%-/}' for the podcast name. OK? [y,N]: "

  done
  feedName="${${${${name//[: ,\!)(]/-}//[\"\']/}//--/-}/%-/}"

  ##########################################################################################
  ## Get the "category" for this podcast. Use a Rivendell GROUP for the category name.
  ##########################################################################################
  # See zsh-functions for the definition of doSQL.
  rivendellGroupList=$(doSQL "select NAME from GROUPS order by NAME")

  # List the groups and prompt them for a group to use if they asked for
  # a list or if they did not name a group.
  if [[ -z "${group}" ]] || [[ "${group}" =~ 'list' ]] ; then

    echo "\nCurrent list of GROUPs:"
    ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${rivendellGroupList}
    read group\?"Type the name of the Rivendell GROUP into which this podcast will be imported: "

  fi

  # Validate the group against the current known list of groups in the
  # Rivendell database.
  until ${GREP} -q "^${group}$" <<< ${rivendellGroupList} ; do

    warning "'${group}' is not in the list. Please use a valid GROUP name."

    echo "Current list of GROUPs:"
    ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${rivendellGroupList}
    read group\?"Enter the Rivendell GROUP into which this podcast will be imported: "

  done

  (( verbose )) && echo ${feedURL} ${group} ${feedName}${feedUser:+" USER:${feedUser}"}${feedPassword:+" PASS:${feedPassword}"}

  [[ -w ${DIR_CONFIG}/${CONFIG_SERVERLIST} ]] ||
    return $(error "Missing access rights to modify the file ${DIR_CONFIG}/${CONFIG_SERVERLIST}")

  local tmpfile=$(mktemp)
  trap "${RM} -f ${tmpfile}; trap - ; return ;" 0 1 2 3

  # Same group and name (possibly different URL?).
  if ${GREP} -P -q "^[^#].*\s+${group}\s+${feedName}\s*" ${DIR_CONFIG}/${CONFIG_SERVERLIST} ; then

    addNewFeed=0
    read -q ok\?"${feedName} already exists in group ${group}. Replace? [y,N] "
    if [[ "${ok}" = y ]] ; then

      ${GREP} -P -v "^[^#].*\s+${group}\s+${feedName}\s*" ${DIR_CONFIG}/${CONFIG_SERVERLIST} > ${tmpfile}
      replaceFeed=1

    fi

  # Same name, different group.
  elif ${GREP} -P -q "^[^#].*\s+${feedName}\s*" ${DIR_CONFIG}/${CONFIG_SERVERLIST} ; then

    addNewFeed=0
    read -q ok\?"${feedName} already exists in a different group. Change to group '${group}'? [y,N] "
    if [[ "${ok}" = y ]] ; then

      ${GREP} -P -v "^[^#].*\s+${feedName}\s*" ${DIR_CONFIG}/${CONFIG_SERVERLIST} > ${tmpfile}
      replaceFeed=1

    fi
  fi

  if (( addNewFeed || ! replaceFeed )) ; then

    # A new feed.
    ${CP} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ${tmpfile}

  fi

  if (( addNewFeed || replaceFeed )) ; then

      ${CAT} <<EOF >> ${tmpfile}
${feedURL} ${group} ${feedName}${feedUser:+" USER:${feedUser}"}${feedPassword:+" PASS:${feedPassword}"}
EOF

  fi

  if [[ -s ${tmpfile} ]] ; then

    # There should be no more than two lines of difference between the
    # original and the edited file.
    if (( $(${DIFF} --side-by-side --suppress-common-lines ${DIR_CONFIG}/${CONFIG_SERVERLIST} ${tmpfile} | ${WC} -l) <= 2 )) ; then

      # We made a tmpfile, so replace serverlist with its contents.
      ${MV} ${tmpfile} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ||
	return $(error "Could not replace ${DIR_CONFIG}/${CONFIG_SERVERLIST}.")

      ${CHMOD} 644 ${DIR_CONFIG}/${CONFIG_SERVERLIST}

      ${MKDIR} -p ${DIR_LIBRARY}/${group}/${feedName} ||
	warning "Failed to create new podcast directory ${DIR_LIBRARY}/${group}/${feedName} (${?}). You may have to create this yourself."

      echo

      # Offer to create a Rivendell dropbox if we are making changes
      # to this podcast (new or replace).
      addRDDropbox ${myName} ${DIR_LIBRARY} ${feedName} ${group} ${verbose}

      read ok\?"Podcast $( (( replaceFeed )) && echo replaced || echo added). Press <Enter> to continue. "

    else

      returnValue=$(error "Found an unexpected error in the new podcast feed file while attempting to add '${feedName}'")
      echo "Restoring backup. Please notify the authorities!"

      (( verbose )) && ${DIFF} --side-by-side --suppress-common-lines ${DIR_CONFIG}/${CONFIG_SERVERLIST} ${tmpfile}
      ${MV} ${backupServerlist} ${DIR_CONFIG}/${CONFIG_SERVERLIST}

      read ok\?"Press <Enter> to continue. "

    fi

  else

    returnValue=$(error "Found an empty podcast feed file while attempting to add feed '${feedName}'")
    echo "Restoring backup. Please notify the authorities!"

    ${MV} ${backupServerlist} ${DIR_CONFIG}/${CONFIG_SERVERLIST}

    read ok\?"Press <Enter> to continue. "

  fi

  trap -
}

enableFeed() {
  local myName=${1} ; shift
  local verbose=${1}

  local feedList feedNameEntered feedName tmpfile

  trap 'trap - 0 1 2 3 ; return ;' 0 1 2 3

  feedList=$(${GREP} '^#DISABLED#' ${DIR_CONFIG}/${CONFIG_SERVERLIST} | ${AWK} '{print $3}')

  # Try to enable feeds only if there actually are any disabled ones.
  if [[ -n "${feedList}" ]] ; then

    if (( $(${WC} -l <<<${feedList}) > 1 )) ; then

      echo "Current list of disabled podcast feeds:"
      ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
      read feedNameEntered\?"Enter the name of the podcast ('*' wildcard OK) you want to enable (and press <Enter>): "

      # Allow '*'-style wildcards in the feedName, will expand it below.
      until feedName=$(${GREP} "^${feedNameEntered//\*/.*}$" <<< ${feedList}) ; do

	warning "'${feedNameEntered}' is not in the list. Please use a valid feed name."

	echo "Current list of disabled podcast feeds:"
	${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
	read feedNameEntered\?"Type or paste the name of the podcast ('*' wildcard OK) you want to enable: "

      done

    else

      # There is only one feed to enable, so do not bother prompting for it.
      feedName=${feedList}

    fi

    echo "Enabling '${feedName}' in the feed list... \c"

    trap "${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ; trap - ; return ;" 0 1 2 3

    ${SED} -i.bak -e "/^#DISABLED#.*[[:space:]]${feedName}[[:space:]]*/s/^#DISABLED#//" ${DIR_CONFIG}/${CONFIG_SERVERLIST}
    # The sed command *should* result in exactly one line of
    # difference between the original and the edited file.
    if (( $(${DIFF} --side-by-side --suppress-common-lines ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ${DIR_CONFIG}/${CONFIG_SERVERLIST} | ${WC} -l) == 1 )) ; then

      ${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak
      echo "Done."

    else

      warning "Could not properly enable the disabled podcast feed '${feedName}'.
Please fix the file '${DIR_CONFIG}/${CONFIG_SERVERLIST}' manually."

      ${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak

    fi

    read ok\?"Press <Enter> to continue. "

  else

    read ok\?"There are no disabled feeds available. Press <Enter> to continue. "

  fi

  trap -
}

deleteFeed() {
  local myName=${1} ; shift
  local verbose=${1}

  local feedList feedNameEntered feedName deleteOrDisable tmpfile

  trap 'trap - ; return ;' 0 1 2 3

  feedList=$(${GREP} -v '^#' ${DIR_CONFIG}/${CONFIG_SERVERLIST} | ${AWK} '{print $3}')

  # Delete feeds only if there actually are any available.
  if [[ -n "${feedList}" ]] ; then

    # Prompt for a feed to delete only if there is more than one in
    # the list.
    if (( $(${WC} -l <<<${feedList}) > 1 )) ; then

      echo "Current list of podcast feeds:"
      ${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
      read feedNameEntered\?"Enter the name of the podcast ('*' wildcard OK) you want to delete or disable (and press <Enter>): "

      until feedName=$(${GREP} "^${feedNameEntered//\*/.*}$" <<< ${feedList}) ; do

	warning "'${feedNameEntered}' is not in the list. Please use a valid feed name."

	echo "Current list of podcast feeds:"
	${COLUMN} -x -c $(( COLUMNS > 80 ? 78 : COLUMNS )) <<< ${feedList}
	read feedNameEntered\?"Enter the name of the podcast ('*' wildcard OK) you want to delete or disable: "

      done

    else

      # Only one feed, so offer it for deletion.
      feedName=${feedList}

    fi

    read -k 1 deleteOrDisable\?"Do you want to disable (d) or delete (D) '${feedName}'? "
    until [[ "${deleteOrDisable}" =~ '[Dd]' ]] ; do
      echo
      read -k 1 deleteOrDisable\?"Please type a lower case 'd' for 'disable' or an upper case 'D' for 'delete' "
    done
    echo

    if [[ "${deleteOrDisable}" = 'd' ]] ; then

      echo "Disabling '${feedName}' in the feed list... \c"

      trap "${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ; trap - ; return ;" 0 1 2 3

      ${SED} -i.bak -e "/[[:space:]]${feedName}[[:space:]]*/s/^/#DISABLED#/" ${DIR_CONFIG}/${CONFIG_SERVERLIST}
      # The sed command *should* result in exactly one line of
      # difference between the original and the edited file.
      if (( $(${DIFF} --side-by-side --suppress-common-lines ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak ${DIR_CONFIG}/${CONFIG_SERVERLIST} | ${WC} -l) == 1 )) ; then

	${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak
	echo "Done."

      else

	warning "Could not properly disable the podcast feed '${feedName}'. Please fix the file '${DIR_CONFIG}/${CONFIG_SERVERLIST}' manually."

	${RM} -f ${DIR_CONFIG}/${CONFIG_SERVERLIST}.bak

      fi

      trap 'trap - ; return ;' 0 1 2 3

    elif [[ "${deleteOrDisable}" = 'D' ]] ; then

      echo "Deleting feed '${feedName}' from the feed list... \c"

      tmpfile=$(mktemp)
      trap "${RM} -f ${tmpfile}; trap - ; return ;" 0 1 2 3

      ${GREP} -v "[[:space:]]${feedName}[[:space:]]*" ${DIR_CONFIG}/${CONFIG_SERVERLIST} > ${tmpfile}

      if [[ -s ${tmpfile} ]] ; then

	if ${MV} ${tmpfile} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ; then

	  echo "Done."

	else

	  warning "Could not replace '${DIR_CONFIG}/${CONFIG_SERVERLIST}' with the deleted podcast feed. Do you have the access rights to replace this file? Please fix the file '${DIR_CONFIG}/${CONFIG_SERVERLIST}' manually."

	fi
      else

	warning "Unable to find '${feedName}' in ${DIR_CONFIG}/${CONFIG_SERVERLIST}. Please fix the file ${DIR_CONFIG}/${CONFIG_SERVERLIST} manually."

      fi

    else

      echo "\nWTF? How did you get past the prompt without entering a 'd' or a 'D'?"

    fi

    trap 'trap - ; return ;' 0 1 2 3

    read ok\?"Press <Enter> to continue. "

  else

    read ok\?"There are no feeds available to delete. Press <Enter> to continue. "

  fi

  trap -
}

listFeeds() {
  local myName=${1} ; shift
  local verbose=${1}

  trap 'trap - ; return ;' 0 1 2 3

  (
    # The header.
    reportTitleText="Kuchota Podcasts"
    reportTitle="$(printf ' %.0s' {1..$(( ( ${terminfo[cols]} - ${#reportTitleText} ) / 2 ))})${reportTitleText}"
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
    print "${reportTitle}"
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
    printf '%-46s %-16s %-48s\n'  "Title" "Group" "Credentials"
    printf '-%.0s' {1..46}; printf '-%.0s' {1..16}; printf '-%.0s' {1..48}; print

    # The content.
    ${SED} -e '1,/^# ---------/d' < ${DIR_CONFIG}/${CONFIG_SERVERLIST} |
      ${GREP} -v '^ *$' |
      ${SORT} --ignore-case --key=3,3 --key=2,2 |
      while read url group title rest ; do
	if [[ ${url} =~ '#DISABLED#.*' ]] ; then
	  title="${RED}DISABLED:${NORM} ${title}"
	  url="${RED}DISABLED:${NORM} ${url/\#DISABLED#/}"
	fi
	rdDropBoxPath="${DIR_LIBRARY}/${group}/${title}/*.mp3"
	printf '%-46s %-16s %-48s\n%-80s\nRD DropBox: %-80s\n\n' ${title} ${group} ${rest:-""} ${url} "${rdDropBoxPath//${RED}DISABLED:${NORM} }"
      done

    # The footer.
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
  ) | ${LESS} -RCiP "Viewing podcast feeds?e (End of Output).\. Press <q> to quit, <PgDown> and <PgUP> to scroll\."

  trap -
}

showLastStatus() {
  local myName=${1} ; shift
  local type=${1} ; shift
  local verbose=${1}

  local statusFile=${STATUS_FILE:-${ROOT:-/}var/tmp/pmw-podget-wrapper.${type}}

  trap 'trap - ; return ;' 0 1 2 3

  case ${type} in
    out) OUTPUT="output results" ;;
    err) OUTPUT="diagnostic output" ;;
  esac

  (
    # The header.
    reportTitleText="Latest Kuchota 'podget' ${(C)OUTPUT}"
    reportTitle="$(printf ' %.0s' {1..$(( ( ${terminfo[cols]} - ${#reportTitleText} ) / 2 ))})${reportTitleText}"
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
    print "${reportTitle}"
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print

    # The data.
    ${CAT} ${statusFile}

    # The footer.
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
  ) | ${LESS} -RCiP "Viewing the latest podget ${OUTPUT}?e (End of Output).\. Press <q> to quit, <PgDown> and <PgUP> to scroll\."

  trap -
}

editSchedule() {
  local myName=${1} ; shift
  local verbose=${1}

  local minute oMinute hour oHour crontab answer ok

  trap 'trap - ; return ;' 0 1 2 3

  # Snag the current crontab for later processing.
  crontab=$(${CRONTAB} -l)

  # Give them the opportunity to change the existing schedule.
  if ${GREP} -q 'pmw-podget-wrapper' <<<"${crontab:-X}" ; then

  ${CAT} <<EOF

The current schedule for downloading podcasts is as follows. This is
the entire crontab entry. '${BOLD}pmw-podget-wraper${NORM}' is the tool used to
launch and track '${BOLD}podget${NORM}', the downloader app.

${BOLD}$(${GREP} 'podget-wrapper' <<<${crontab})${NORM}

EOF

  read -q change\?"Do you want to change the schedule? [y,N] "
  case ${change} in
    [Nn]) echo "Leaving the download schedule as it is." ; trap - ; return ;;
  esac

  # Pre-fill the vailues we will later prompt for.
  minute=$(${GREP} '^[^#].*podget-wrapper' <<<${crontab} | ${AWK} '{print $1}')
  hour=$(${GREP} '^[^#].*podget-wrapper' <<<${crontab} | ${AWK} '{print $2}')

  fi

  ${CAT} <<EOF


${(C)myName} runs the 'pmw-podget-wrapper' backend periodically in
order to check for new episodes of podcasts. I check all podcasts
each time, downloading new episodes for each podcast as they appear.

Typically, 'pmw-podget-wrapper' runs from cron at least once an hour
every day. I'll assume you want to do that. You will need to update
the cron job manually (using the 'crontab' command) only if you want a
different schedule.

Valid hours are 0 - 23 and '*'.

EOF

  until [[ "${ok}" =~ '[Yy]' ]] ; do

    oHour=${hour}
    read hour\?"Type the hour(s) you want ${myName} to check for new podcasts (enter '*' for every hour): ${hour:+'[${hour}] '}"
    [[ -z "${hour}" ]] && hour=${oHour}
    until [[ "${hour}" =~ '^(\*|[[:digit:],]+)$' ]] ; do

      echo "You need to enter either an asterisk ('*'), or some combination of hour numbers and commas."
      read hour\?"Type the hour(s) you want ${myName} to check for new podcasts (enter '*' for every hour): "

    done

    ${CAT} <<EOF

Now I need to know how many times an hour you want to check for new
podcasts. You can enter a single "minute" representing once an hour,
or you can enter multiple minutes separated with commas (','). Valid
minutes are 0 - 59.

EOF

    oMinute=${minute}
    read minute\?"Enter the minute(s) of the hour(s) ('${hour}') you want to check for podcasts: ${minute:+'[${minute}] '}"
    [[ -z "${minute}" ]] && minute=${oMinute}
    until [[ "${minute}" =~ '^[[:digit:],]+$' ]] ; do

      echo "You need to enter combination of minute numbers and commas."
      read minute\?"Type the minute(s) of the hour(s) ('${hour}') you want to check for podcasts: "

    done

    echo "Using 'hour: ${hour}' and 'minute: ${minute}' for the podcast download schedule."
    read -q ok\?"OK to commit this schedule? [y,N]"
    echo

  done

  (
    echo ${crontab} | ${GREP} -v 'pmw-podget-wrapper'
    echo "${minute} ${hour} * * * zsh /usr/local/bin/pmw-podget-wrapper" 
  ) | ${CRONTAB} -

  ${CAT} <<EOF

Here is the complete cron entry for downloading podcasts:

$(${CRONTAB} -l | ${GREP} --perl-regexp '^(#|.*podget-wrapper)')

EOF

  trap -
}

editFile() {
  local myName=${1} ; shift
  local filename=${1} ; shift
  local verbose=${1}

  trap 'trap - ; return ;' 0 1 2 3

  ${VISUAL:-${EDITOR:-nano}} ${filename}

  trap -
}

cronEdit() {
  local myName=${1} ; shift
  local verbose=${1}

  trap 'trap - ; return ;' 0 1 2 3

  EDITOR=${VISUAL:-${EDITOR:-nano}} ${CRONTAB} -e

  trap -
}

addRDDropbox() {
  local myName=${1} ; shift
  local dirLibrary=${1} ; shift
  local feedName=${1} ; shift
  local feedGroup=${1} ; shift
  local verbose=${1}

  trap 'trap - 0 1 2 3 ; return ;' 0 1 2 3

  if (( rdDBVersionCompatible != $(rdDatabaseVersion) )) ; then

    return $(error "This version of ${myName} is not compatible with Rivendell database version '$(rdDatabaseVersion)'. You need to create a dropbox manually.")

  fi

  # See whether there is a dropbox with a matching pathname.
  query="select d.ID,d.PATH,d.TO_CART,d.GROUP_NAME from DROPBOXES d where d.PATH like '${DIR_LIBRARY}/${feedGroup}/${feedName}/%'"
  read dropboxID dropboxPATH dropboxCARTNUM dropboxGROUP <<<$(doSQL "${query}")
  if (( dropboxID )) ; then

    info="It appears as if Rivendell dropbox '${dropboxID}' watches for files at '${dropboxPATH}'."

    if (( dropboxCARTNUM )) ; then

      query="select TITLE from CART where NUMBER = ${dropboxCARTNUM}"
      read cartTITLE <<<$(doSQL "${query}")

      info="${info} The dropbox uses the CART '${cartTITLE}' (number ${dropboxCARTNUM})."

      ${FMT} <<<${info}

    else

      info="${info} This dropbox assigns new carts in group '${dropboxGROUP}'."

      ${FMT} <<<${info}

    fi

    if read -q answer\?"Do you want to use this dropbox for the feed '${feedName}'? [y,N] " ; then

      echo "\nOK, using existing dropbox."

    else

      echo "\nOK, creating a new dropbox for feed '${feedName}'."
      createnewdropbox
    fi

  else

    if read -q answer\?"Would you like to set up a Rivendell dropbox for '${feedName}'? [y,N] " ; then

      echo
      if read -q answer\?"For this dropbox, do you want to create a new CART and assign this podcast to it? [y,N] " ; then

	echo
	if dropboxID=$(createDropbox ${feedGroup} ${feedName} ${DIR_LIBRARY} ${fileExt} $(rdCreateEmptyCart ${feedGroup} ${feedName}) ${verbose}) ; then
	  echo "Dropbox number ${dropboxID} created."
	else
	  warning "Error creating dropbox for feed '${feedName}'. Please notify the authorities!"
	fi
      else

	echo
	if read -q answer\?"OK, do you want each new episode of '${feedName}' to be placed into its own new cart? [y,N] " ; then

	  echo
	  if dropboxID=$(createDropbox ${feedGroup} ${feedName} ${DIR_LIBRARY} ${fileExt} 0 ${verbose}) ; then
	    echo "Dropbox number ${dropboxID} created."
	  else
	    warning "Error creating dropbox for feed '${feedName}'. Seek professional help!"
	  fi
	else

	  ${CAT} <<EOF


$(${FMT} <<<"Well, you're not assigning a specific cart to this podcast, and you're not using a new cart for each episode. You're on your own...")

EOF

	fi
      fi
    else

      echo
      echo "OK, but you may want to add a Rivendell dropbox on your own."

    fi
  fi

  trap -
}

showRDDropboxes() {
  local myName=${1} ; shift
  local verbose=${1}

  local query="select d.ID,d.PATH,d.GROUP_NAME,d.TO_CART,c.TITLE from DROPBOXES d left join CART c on (d.TO_CART = c.NUMBER) where d.PATH like '${DIR_LIBRARY}/%'"
  local id path group cart title

  trap 'trap - 0 1 2 3 ; return ;' 0 1 2 3

  if (( rdDBVersionCompatible != $(rdDatabaseVersion) )) ; then

    return $(error "This version of ${myName} is not compatible with Rivendell database version '$(rdDatabaseVersion)'. You need to create a dropbox manually.")

  fi

  (
    # The header.
    reportTitleText="Kuchota-related (not all) Rivendell Dropboxes"
    reportTitle="$(printf ' %.0s' {1..$(( ( ${terminfo[cols]} - ${#reportTitleText} ) / 2 ))})${reportTitleText}"
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
    print "${reportTitle}"
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print
    printf '%3s %-64s %-12s %6s %-32s\n'  "ID" "Dropbox Path Spec" "Group" "CART #" "Title"
    printf '-%.0s' {1..$((4+65+13+7+32))}; print

    # The data.
    doSQL "${query}" | while read id path group cart title ; do

      if (( cart == 0 )) ; then
	title='** New cart for each episode **'
      fi

      printf '%3d %-64s %-12s %06d %-32s\n' ${id} ${path} ${group} ${cart} ${title}

    done

    # The footer.
    printf ' '; printf '=%.0s' {1..$(( ${terminfo[cols]} - 2 ))} ; print

  ) | ${LESS} -RCiP "Viewing Rivendell Dropboxes for Kuchota?e (End of Output).\. Press <q> to quit, <PgDown> and <PgUP> to scroll\."

  trap -
}

showDropboxStatus() {
  local myName=${1} ; shift
  local verbose=${1}

  local ok

  # Second arg indicates we are calling rdDropboxStatus interactively.
  rdDropboxStatus ${myName} 1 ${verbose}

  echo
  read ok\?"Press <Enter> to continue. "
}

makeParser() {
  local selection=${1:?"Need an XML selection."}
  local tempfile=$(mktemp)
  
  ${CAT} > ${tempfile} <<EOF
<?xml version="1.0"?>
<stylesheet version="1.0"
	xmlns="http://www.w3.org/1999/XSL/Transform">
	<output method="text"/>
	<template match="/">
		<apply-templates select="${selection}"/>
	</template>
	<template match="enclosure">
		<value-of select="@url"/><text>&#10;</text>
	</template>
</stylesheet>
EOF

  echo ${tempfile}
}

createDropbox() {
  local feedGroup=${1:?"Need a Rivendell GROUP to assign to this dropbox."} ; shift
  local feedName=${1:?"Need a podcast feed name for this dropbox."} ; shift
  local dirLibrary=${1:?"Need a DIR_LIBRARY for this dropbox."} ; shift
  local fileExt=${1:?"Need a file extension (type) for this dropbox."} ; shift
  local cartNumber=${1:?"Need a CART number for this dropbox."} ; shift
  local verbose=${1}

  local dropboxPath="${dirLibrary}/${feedGroup}/${feedName}"
  local returnValue=0
  local stationName dropboxID
  local -a query

  if stationName=$(rdGetStationName) ; then

    query=(
      "insert into DROPBOXES"
      "(STATION_NAME, GROUP_NAME, PATH, NORMALIZATION_LEVEL, AUTOTRIM_LEVEL, TO_CART, FIX_BROKEN_FORMATS, LOG_PATH)"
      "values"
      "('${stationName}', '${feedGroup}', '${dropboxPath}/*.${fileExt}', -100, -5000, ${cartNumber}, 'Y', '${dropboxPath}/rdimport.log')"
    )

    if doSQL "${(j: :)query}" ; then

      # Make sure we created the new dropbox
      dropboxID=$(doSQL "select ID from DROPBOXES where PATH = '${dropboxPath}/*.${fileExt}'")

      if [[ -z "${dropboxID}" ]] ; then

	echo "Unable to discern the new dropbox ID. Did the dropbox get created?" >&2
	returnValue=1

      else
	echo ${dropboxID}
      fi

    else

      echo "Attempt to create new dropbox failed (${?}). Please seek professional advice." >&2
      returnValue=1

    fi

  else

    returnValue=2

  fi

  return ${returnValue}
}

warning() {
  local message=${1}

  ${CAT} >&2 <<EOF

${BOLD}${RED}WARNING:${NORM}
$(${FMT} -w 79 <<< ${message})

EOF
}

error() {
  local message=${1}

  ${CAT} >&2 <<EOF

${RED}${BOLD}ERROR:${NORM}
$(${FMT} -w 79 <<< ${message})

EOF
  echo 254
  return 254
}

##########################################################################################
## Script main line
##########################################################################################

# The shell commands we will use in this script.
typeset -a ourCommands
ourCommands=(
  awk
  cat
  chmod
  column
  cp
  crontab
  diff
  fmt
  getopt
  grep
  less
  mkdir
  mv
  podget
  rm
  sed
  sort
  wc
  wget
  xsltproc
)

# Find the executables we need; this uses a little old fashioned shell and
# a ZSH trick -- the (U) in the eval(1) says to evaluate the parameter as
# all upper case letters. We will use the command names in upper case as
# variables by which to call the commands later in this function.
for C in ${ourCommands} ; do
  for D in ${path} ; do
    [[ -x ${D}/${C} ]] && { eval ${(U)C}=${D}/${C} ; break }
  done
  [[ -x $(eval echo \$${(U)C}) ]] || { echo "Cannot find ${C}! Done."; return 1 }
done

# Set some defaults, and see below for more ways to set these.
DIR_CONFIG=%PODGET_DIR_CONFIG%
CONFIG_CORE=podgetrc
CONFIG_NOTIFY=notifyrc

TEMP=$(${GETOPT} -o c:Dd:Vvg:h --long config:,debug,dir-config:,version,verbose,group:,help -n "${0##*/}" -- "${@}")
if (( ${?} != 0 )) ; then echo "Terminating..." >&2 ; return 1 ; fi
# Note the quotes around ${TEMP}: they are essential!
eval set -- "${TEMP}"
while : ; do
  case "${1}" in
    -D|--debu*) DEBUG=1 ; shift ;;
    -c|--conf*) CONFIG_CORE=${2} ; shift 2 ;;
    -d|--dir-*) DIR_CONFIG=${2} ; shift 2 ;;
    -g|--grou*) group=${2} ; shift 2 ;;
    -h|--help*) usage ${0##*/} ; exit ;;
    -v|--verb*) VERBOSE=1 ; PASSFILE=none ; shift ;;
    -V|--vers*) showVersion=1 ; shift ;;
    --) shift ; break ;;
    *) echo "Internal error!" >&2 ; return 1 ;;
  esac
done

if ((showVersion)) ; then
  echo "${0##*/}: version ${vMajor}.${vMinor}.${vPatch}-${${vHash#\$Hash: }%$}"
  exit 0
fi

RED="${fg_bold[red]}"
BOLD="${bold_color}"
NORM="${reset_color}"
# This script is compatible with Rivendell database verson:
rdDBVersionCompatible=242
# Hard code this for now.
fileExt=mp3

# Ensure the configuration directory exists.
if [[ ! -d ${DIR_CONFIG} ]] ; then
  if ! ${MKDIR} -p ${DIR_CONFIG} ; then

    ${CAT} >&2 <<EOF
${BOLD}${RED}
ERROR: unable to create configuration directory '${DIR_CONFIG}'. Make
sure your permissions are set so that you have file create and write
rights to the ${DIR_CONFIG} directory.

Cannot continue.
${NORM}
EOF
    exit 2

  fi
fi

# Run podget(1) if it appears it has never been run.
failCount=1
maxAttempts=10
until [[ -r ${DIR_CONFIG}/${CONFIG_CORE} ]] ; do

  warning "Unable to read configuration file ${DIR_CONFIG}/${CONFIG_CORE}. Running podget to create a new configuration..."

  ${PODGET} --dir_config ${DIR_CONFIG}

  ((failCount++ > maxAttempts )) &&
    exit $(error "Unable to create ${DIR_CONFIG}/${CONFIG_CORE} ${maxAttempts} times. I quit.")

done

[[ -r ${DIR_CONFIG}/${CONFIG_CORE} ]] && source ${DIR_CONFIG}/${CONFIG_CORE}
[[ -n "${CONFIG_SERVERLIST}" ]] ||
  exit $(error "Failed to get a setting for 'CONFIG_SERVERLIST'. Does '${DIR_CONFIG}/${CONFIG_CORE}' exist?")

##########################################################################################
## The guts of why we are here.
##########################################################################################

typeset -a menu command
typeset -R 2 count

while : ; do
    count=0

    menu=(
      "Quit"
      "Add or Replace a podcast feed"
      "Delete or disable a podcast feed"
      "Enable a disabled podcast feed"
      "Show the complete list of podcast feeds"
      "Show most recent podget run status"
      "Show most recent podget diagnostic status"
      "View and set the podget run schedule \(crontab\)"
      "Show Rivendell dropboxes"
      "Show Rivendell dropbox status"
      "\[Advanced\] Edit the podcast list with '${EDITOR:-${VISUAL:-nano}}'"
      "\[Advanced\] Edit the notification configuration with '${EDITOR:-${VISUAL:-nano}}'"
      "\[Advanced\] Edit ${USER}\'s crontab file"
    )
    command=(
      'addOrReplaceFeed ${0##*/} ${verbose}'
      'deleteFeed ${0##*/} ${verbose}'
      'enableFeed ${0##*/} ${verbose}'
      'listFeeds ${0##*/} ${verbose}'
      'showLastStatus ${0##*/} out ${verbose}'
      'showLastStatus ${0##*/} err ${verbose}'
      'editSchedule ${0##*/} ${verbose}'
      'showRDDropboxes ${0##*/} ${verbose}'
      'showDropboxStatus ${0##*/} ${verbose}'
      'editFile ${0##*/} ${DIR_CONFIG}/${CONFIG_SERVERLIST} ${verbose}'
      'editFile ${0##*/} ${DIR_CONFIG}/${CONFIG_NOTIFY} ${verbose}'
      'cronEdit ${0##*/} ${verbose}'
    )
    windowTitle=(
      "Add Feed"
      "Delete Feed"
      "Enable Feed"
      "List Feeds"
      "podget Run Status"
      "podget Diagnostic Status"
      "Edit run Schedule"
      "Rivendell Dropboxes"
      "Rivendell Dropbox Status"
      "Edit serverlist"
      "Edit notifyrc"
      "Edit crontab"
    )

    # Set the window title.
    printf '\033]0;%s\007' Kuchota

    for menuItem in ${menu} ; do
	echo "${count}) $(eval echo ${menuItem})"
	(( count++ ))
    done
    echo

    read choice\?"Type your choice and press <Enter>: "

    echo

    if [[ -z "${choice}" ]] ; then
      echo "Please enter a number between 0 and $(( count - 1 ))."

    elif [[ ${choice} =~ '^[0Qq]$' ]] ; then
      exit

    elif [[ "${choice}" =~ '[[:space:]]*[[:alpha:]]+' ]] ; then
      echo "'${choice}' is not an option. Please enter a number between 0 and $(( count - 1 ))."

    elif [[ "${choice}" =~ '[[:space:]]*[[:alnum:]]+[[:space:]]+' ]] ; then
      echo "'${choice}' is not an option (watch your spaces). Please enter a number between 0 and $(( count - 1 ))."

    elif (( choice > 0 && choice < count )) ; then

      # Set the window title for this menu choice then run the command.
      printf '\033]0;%s\007' ${windoTitle[${choice}]}
      eval $(echo ${command[${choice}]})

    else
	echo "'${choice}' is not an option. Please enter a number between 0 and $(( count - 1 ))."

    fi

    # As found in ZSH module zsh/terminfo.
    echoti clear
done

exit

# Local Variables: ***
# mode:shell-script ***
# indent-tabs-mode: f ***
# sh-indentation: 2 ***
# sh-basic-offset: 2 ***
# sh-indent-for-do: 0 ***
# sh-indent-after-do: + ***
# sh-indent-comment: t ***
# sh-indent-after-case: + ***
# sh-indent-after-done: 0 ***
# sh-indent-after-else: + ***
# sh-indent-after-if: + ***
# sh-indent-after-loop-construct: + ***
# sh-indent-after-open: + ***
# sh-indent-after-switch: + ***
# sh-indent-for-case-alt: ++ ***
# sh-indent-for-case-label: + ***
# sh-indent-for-continuation: + ***
# sh-indent-for-done: 0 ***
# sh-indent-for-else: 0 ***
# sh-indent-for-fi: 0 ***
# sh-indent-for-then: 0 ***
# End: ***
