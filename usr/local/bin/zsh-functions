#!/bin/zsh

##############################################################################
#
# This is a "library" of zsh(1) functions used by all the Phantom
# Machine Works Z-Shell scripts. All scripts that need any functions
# should "source" this file. This script is NOT intended to be "run"
# from the command line.
#
##############################################################################

# Use the configured mailer to send email to one or more addresses.
sendNotification() {
  local myName=${1:?"Who am I?"} ; shift
  local MAILTO=${1:?"Need one or more recipients to send to."} ; shift
  local message=${1:?"Need a message to send for the notification."} ; shift
  local messagefile=${1} # optional text filename to attach

  local MAILER_CONFIG=${MAILER_CONFIG:-${ROOT:-/}usr/local/etc/pmw/conf.msmtp}
  local MAILER_ARGS="--read-recipients --read-envelope-from  --file ${MAILER_CONFIG}"
  local PRETEND=${PRETEND}

  local BASE64=$(whence base64) ; BASE64=${BASE64:-/usr/bin/base64}
  local CAT=$(whence cat) ; CAT=${CAT:-/bin/cat}
  local DOS2UNIX=$(whence dos2unix) ; DOS2UNIX=${DOS2UNIX:-${ROOT:-/}usr/bin/logger}
  local HOSTNAME=$(whence hostname) ; HOSTNAME=${HOSTNAME:-${ROOT:-/}bin/hostname}
  local LOGGER=$(whence logger) ; LOGGER=${LOGGER:-${ROOT:-/}usr/bin/logger}
  local MAILER=$(whence msmtp) ; MAILER=${MAILER:-${ROOT:-/}usr/bin/msmtp}
  local UUIDGEN=$(whence uuidgen) ; UUIDGEN=${UUIDGEN:-${ROOT:-/}usr/bin/uuidgen}

  if [[ -x ${MAILER} ]] ; then

    if [[ -s ${MAILER_CONFIG} ]] ; then

      (
	${CAT} <<EOF
To: ${${MAILTO//( |[ ,][ ,])/,}%,}
From: No-Reply@$(${HOSTNAME} -f)
Reply-To: No-Reply@$(${HOSTNAME} -f)
Subject: rddbcheck Output from ${myName}
Message-ID: <$(${UUIDGEN})-${EPOCHSECONDS}@$(${HOSTNAME} -f)>
X-Script-Name: ${myName}
MIME-Version: 1.0
Content-Type: multipart/mixed;
 boundary="----------${startTime}"

This is a multi-part message in MIME format.
------------${startTime}
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: 8bit

${message}

EOF
	if [[ -n "${messagefile}" ]] && [[ -s ${messagefile} ]] ; then
	  ${CAT} <<EOF
------------${startTime}
Content-Type: text/plain; charset=UTF-8;
 name="${messagefile##*/}"
Content-Transfer-Encoding: base64
Content-Disposition: attachment;
 filename="${messagefile##*/}"

$(${DOS2UNIX} < ${messagefile} | ${BASE64})
EOF
	fi

	${CAT} <<EOF
------------${startTime}--
EOF
      ) | ${MAILER} $(eval echo ${MAILER_ARGS}) ${PRETEND}

    else

      ${LOGGER} -t ${0##*/} -p local7.err -i "ERROR: Cannot find mailer configuration '${MAILER_CONFIG}'. Cannot send messages."

    fi

  else

    ${LOGGER} -t ${0##*/} -p local7.err -i "ERROR: Cannot find executable program '${MAILER}'. Cannot send messages."

  fi
}

# Make mysql calls look a bit more asthetically pleasing. The return
# value of this shell funtion is the exit value of the mysql command
# invocation.
doSQL() {
  local statement="${1:?Need a database query to run.}"
  local useMyCNF=0
  local usableMyCNF=4
  local rdconfig=${RD_CONFIG:-${ROOT:-/}etc/rd.conf}
  local MYSQL=$(whence mysql) ; MYSQL=${MYSQL:-${ROOT:-/}usr/bin/mysql}
  local AWK=$(whence awk) ; AWK=${AWK:-${ROOT:-/}usr/bin/awk}
  local EGREP=$(whence egrep) ; EGREP=${EGREP:-${ROOT:-/}bin/egrep}
  local SED=$(whence sed) ; SED=${SED:-${ROOT:-/}bin/sed}

  typeset -gx _DB_HOST _DB_USER _DB_PWD _DB_DATABASE _USE_MYCNF

  zmodload zsh/mapfile

  # Use the exported variables if we have been through this function
  # already. This applies to each running instance of scripts that
  # use this function. This helps prevent the need to look this
  # stuff up every time this function is called.
  if [[ -z "${_DB_HOST}" ]] ; then

    # Rivendell DB Details: Use credentials in ~/.my.cnf if it exists,
    # else get credentials from rd.conf if it exists, else from the
    # environment, else use defaults here.
    # BUG ALERT: this assumes the credentials in .my.cnf are relevant
    # to the Rivendell database.
    if [[ -r ~/.my.cnf ]] && [[ $(${EGREP} -c '^(database|host|user|password)' ~/.my.cnf) -ge 4 ]] ; then
	cd			# Sigh, mapfile cannot deal with path components.
	myCnfLines=( ${mapfile[.my.cnf]} )

	# Need to check for each of these parameters in .my.cnf in
	# order to be able to use it.
	for parm in database host password user ; do
	  if [[ "${myCnfLines}" =~ ${parm} ]] ; then
	    (( useMyCNF++ ))
	  fi
	done
    else
      # Horribly insecure, but this is the "Rivendell Way".
      if [[ -r ${rdconfig} ]] ; then
	HOST=$(${SED} -e '1,/^\[mySQL\]$/d' -e '/^\[/,$d' ${rdconfig} | ${AWK} -F'=' '/^Hostname=/{print $2}')
	USER=$(${SED} -e '1,/^\[mySQL\]$/d' -e '/^\[/,$d' ${rdconfig} | ${AWK} -F'=' '/^Loginname=/{print $2}')
	PASSWORD=$(${SED} -e '1,/^\[mySQL\]$/d' -e '/^\[/,$d' ${rdconfig} | ${AWK} -F'=' '/^Password=/{print $2}')
	DATABASE=$(${SED} -e '1,/^\[mySQL\]$/d' -e '/^\[/,$d' ${rdconfig} | ${AWK} -F'=' '/^Database=/{print $2}')
      else
	# Last ditch effort to set the MySQL access credentials.
	HOST=${RD_DB_HOST:-"localhost"}
	USER=${RD_USER:-"rduser"}
	PASSWORD=${RD_PASS:-"letmein"}
	DATABASE=${RD_DATABASE:-"Rivendell"}
      fi
    fi

    _DB_HOST=${HOST}
    _DB_USER=${USER}
    _DB_PWD=${PASSWORD}
    _DB_DATABASE=${DATABASE}
    _USE_MYCNF=${useMyCNF}
  fi

  if (( _USE_MYCNF == usableMyCNF )) ; then
    ${MYSQL} -s -N -e "${statement}"
  else
    ${MYSQL} -s -N -B -u ${_DB_USER} -p${_DB_PWD} -h ${_DB_HOST} ${_DB_DATABASE} -e "${statement}"
  fi
}

rdDatabaseVersion() {
  doSQL "select DB from VERSION"
}

getMyIPAddresses() {
  local -a ipAddresses
  local returnValue=0

  local AWK=$(whence awk) ; AWK=${AWK:-${ROOT:-/}usr/bin/awk}
  local GREP=$(whence grep) ; GREP=${GREP:-${ROOT:-/}bin/grep}
  local IP=$(whence ip) ; IP=${IP:-${ROOT:-/}sbin/ip}
  local SED=$(whence sed) ; SED=${SED:-${ROOT:-/}bin/sed}

  ipAddresses=( $(${IP} -o -4 addr show | ${GREP} -E -v '^(lo|virbr|tun)' | ${AWK} '{print $4}' | ${SED} -r -e 's,/[[:digit:]]+$,,') )

  if (( ${#ipAddresses} )) ; then
    echo ${(j: :)ipAddresses}
  fi

  return ${returnValue}
}

# Get this hosts Rivendell STATION name. Return TRUE or FALSE
# depending on whether we could figure the name out.
rdGetStationName() {
  local -a myIP
  local stationName foundStationName
  local returnValue=0

  local HOSTNAME=$(whence hostname) ; HOSTNAME=${HOSTNAME:-${ROOT:-/}bin/hostname}
  local myHostname=$(${HOSTNAME} -s)

  # This function is compatible with Rivendell database verson:
  local rdDBVersionCompatible=242

  if (( rdDBVersionCompatible != $(rdDatabaseVersion) )) ; then
    echo "This version of ${0} is not compatible with Rivendell database version '$(rdDatabaseVersion)'."
    return 128
  fi

  # Prefer an exact hostname match.
  stationName=$(doSQL "select NAME from STATIONS where NAME = '${myHostname}'")

  # Otherwise try all our relevant IP addresses.
  if [[ -z "${stationName}" ]] ; then

    for myIP in $(getMyIPAddresses) ; do

      stationName=$(doSQL "select NAME from STATIONS where IPV4_ADDRESS = '${myIP}'")
      [[ -n "${stationName}" ]] && { foundStationName=1 ; break ; }

    done

    if [[ -z "${stationName}" ]] ; then

      # If no match on the IP address, try a fuzzier hostname match.
      stationName=$(doSQL "select NAME from STATIONS where NAME like '%${myHostname}%'")

      if [[ -z "${stationName}" ]] ; then

	logit ${0} 1 "Cannot determine my Rivendell 'STATION' name. Better fix that before continuing."
	returnValue=1

      fi
    fi
  fi

  [[ -n "${stationName}" ]] && echo ${stationName}
  return ${returnValue}
}

# Get the Rivendell Web Server (HTTP_STATION) for this computer.
rdGetWebServer() {
  local returnValue=1

  # This function is compatible with Rivendell database verson:
  local rdDBVersionCompatible=242

  if (( rdDBVersionCompatible != $(rdDatabaseVersion) )) ; then
    echo "This version of ${0} is not compatible with Rivendell database version '$(rdDatabaseVersion)'."
    return 128
  fi

  if myStationName=$(rdGetStationName) ; then
    if myHTTPStationName=$(doSQL "select HTTP_STATION from STATIONS where NAME = '${myStationName}'") ; then
      returnValue=0
      echo ${myHTTPStationName}
    else
      logit ${0} 1 "Could not determine the Rivendell Web Server for this workstation ('${myStationName}')."
    fi
  else
    logit ${0} 1 "Could not determine my host name."
  fi

  return ${returnValue}
}

# Using the Rivendell Web API, delete the CART, all its CUTS, and the
# actual audio file for the specified CART.
rdDropCart() {
  local cart=${1} ; shift
  local verbose=${1}

  local CURL=$(whence curl) ; CURL=${CURL:-${ROOT:-/}usr/bin/curl}
  local httpServer=$(rdGetWebServer)
  local response responseLine
  local returnValue=1

  # Delete this cart (and all its cuts): Command 13: RemoveCart
  curlArguments="-d COMMAND=13 -d LOGIN_NAME='user' -d PASSWORD='' -d CART_NUMBER=${cart}"

  response=$(${CURL} --silent $(eval echo ${curlArguments}) http://${httpServer}/rd-bin/rdxport.cgi)
  while read responseLine ; do
    if [[ ${responseLine} =~ 'ErrorString' ]] ; then
      result=${${responseLine%</ErrorString>*}#*<ErrorString>}
      break
    fi
  done <<<${response}

  [[ "${result:-MISSING RESULT}" = 'OK' ]] && returnValue=0
  echo "${result:-MISSING RESULT}"
  return ${returnValue}
}

# Get a Rivendell CART NUMBER from a TITLE (full or partial).
rdCartNumberFromTitle() {
  local title=${1:?"Need a CART TITLE string to search."} ; shift
  local verbose=${1}

  doSQL "select NUMBER from CART where TITLE like '%${title}%'"
}

# Get a Rivendell CART TITLE from a partial TITLE.
rdCartTitleFromPartial() {
  local title=${1:?"Need a CART TITLE string to search."} ; shift
  local verbose=${1}

  doSQL "select TITLE from CART where TITLE like '%${title}%'"
}

# Get a Rivendell CART TITLE from a CART NUMBER.
rdCartTitleFromNumber() {
  local number=${1:?"Need a CART NUMBER to look up."} ; shift
  local verbose=${1}

  doSQL "select TITLE from CART where NUMBER = ${number}"
}

rdCartGroupFromNumber() {
  local number=${1:?"Need a CART NUMBER to search."} ; shift
  local verbose=${1}

  doSQL "select GROUP_NAME from CART where NUMBER = ${number}"
}

rdMaxCartNumberForGroup() {
  local group=${1:?"Need a GROUP_NAME from which to get the next CART NUMBER."} ; shift
  local verbose=${1}

  # This function is compatible with Rivendell database verson:
  local rdDBVersionCompatible=242

  if (( rdDBVersionCompatible != $(rdDatabaseVersion) )) ; then
    echo "This version of ${0} is not compatible with Rivendell database version '$(rdDatabaseVersion)'."
    return 128
  fi

  local maxCartNum=$(doSQL "select DEFAULT_HIGH_CART from GROUPS where NAME = '${group}'")

  echo ${maxCartNum}
}

rdGetNextCartNumber() {
  local group=${1:?"Need a GROUP_NAME from which to get the next CART NUMBER."} ; shift
  local verbose=${2}

  local currentCartNumber
  local returnValue=0
  local defaultLowCart defaultHighCart lastHigh nextAvailable nextCartNum useThisCartNumber

  # This function is compatible with Rivendell database verson:
  local rdDBVersionCompatible=242

  if (( rdDBVersionCompatible != $(rdDatabaseVersion) )) ; then
    echo "This version of ${0} is not compatible with Rivendell database version '$(rdDatabaseVersion)'."
    return 128
  fi

  # Get the next available cart number from the group if the group is
  # constrained with default low and default high numbers.
  read defaultLowCart defaultHighCart <<<$(doSQL "select DEFAULT_LOW_CART,DEFAULT_HIGH_CART from GROUPS where NAME = '${group}'")
  if (( defaultLowCart )) ; then

    nextAvailable=${defaultLowCart}
    while (( nextAvailable < defaultHighCart )) ; do

      # Try to find an unused cart number starting at
      # DEFAULT_LOW_CART.
      currentCartNumber=$(doSQL "select NUMBER from CART where NUMBER = ${nextAvailable}")
      if (( currentCartNumber )) ; then

	(( nextAvailable++ ))

      else

	useThisCartNumber=${nextAvailable}
	break

      fi
    done

    if (( nextAvailable == defaultHighCart )) ; then

      # Return an error because we hit the end of the group range and
      # did not find a free CART number.
      useThisCartNumber=-1
      returnValue=1

    fi
  else

    # No default low cart in this group (i.e., there is no number
    # range for this group), so find the next available cart number
    # outside all group ranges.
    doSQL 'select DEFAULT_LOW_CART,DEFAULT_HIGH_CART from GROUPS where DEFAULT_LOW_CART > 0 order by DEFAULT_LOW_CART' |
      while read defaultLowCart defaultHighCart ; do

	# Skip this group if its range falls within a previous group
	# range (yes, this can happen).
	(( defaultLowCart < lastHigh )) && continue

	if (( nextAvailable > lastHigh && nextAvailable < defaultLowCart )) ; then

	  # This query will return NULL if there are no assigned carts
	  # in this range, or the highest assigned cart number in the
	  # range.
	  nextCartNum=$(doSQL "select max(NUMBER) from CART where NUMBER >= ${nextAvailable} and NUMBER < ${defaultLowCart}")
	  if [[ -z "${nextCartNum}" ]] || [[ "${nextCartNum}" = 'NULL' ]] ; then

	    useThisCartNumber=${nextAvailable}
	    break

	  fi
	else

	  (( nextAvailable = defaultHighCart + 1 ))

	fi

	lastHigh=${defaultHighCart}
      done
  fi

  if (( useThisCartNumber > 0 )) ; then

    echo ${useThisCartNumber}

  else

    echo "${0}: ERROR: Cannot find the next CART number for GROUP '${group}' (MAX=$(rdMaxCartNumberForGroup ${group}), Next=${nextAvailable})." >&2

  fi

  return ${returnValue}
}

rdCreateEmptyCart() {
  local group=${1:?"Need to specify a GROUP_NAME in which to create the new CART."} ; shift
  local title=${1:?"Need a CART TITLE string to search."} ; shift
  local verbose=${1}

  local -a query
  local newCartNumber
  local returnValue=0

  # This function is compatible with Rivendell database verson:
  local rdDBVersionCompatible=242

  if (( rdDBVersionCompatible != $(rdDatabaseVersion) )) ; then
    echo "This version of ${0} is not compatible with Rivendell database version '$(rdDatabaseVersion)'."
    return 128
  fi

  if newCartNumber=$(rdGetNextCartNumber ${group}) ; then

    if (( newCartNumber > 0 )) ; then

      # Place the query clauses into an array, mostly for visibility.
      query=(
	"insert into CART"
	"(NUMBER, TYPE, GROUP_NAME, TITLE, CUT_QUANTITY)"
	"values"
	"(${newCartNumber}, 1, '${group}', '${title}', 0)"
      )

      doSQL "${(j: :)query}"
      echo ${newCartNumber}

    else

      echo "${0}: ERROR: Could not create a new CART ('${title}') in GROUP '${group}'." >&2
      returnValue=1

    fi
  fi

  return ${returnValue}
}

rdDropboxStatus() {
  local myName=${1} ; shift
  local interactive=${1} ; shift
  local verbose=${1}

  local AWK=$(whence awk) ; AWK=${AWK:-${ROOT:-/}usr/bin/awk}
  local GREP=$(whence grep) ; GREP=${GREP:-${ROOT:-/}bin/grep}
  local HOSTNAME=$(whence hostname) ; HOSTNAME=${HOSTNAME:-${ROOT:-/}bin/hostname}
  local KILLALL=$(whence killall) ; KILLALL=${KILLALL:-${ROOT:-/}usr/bin/killall}
  local PIDOF=$(whence pidof) ; PIDOF=${PIDOF:-${ROOT:-/}bin/pidof}
  local PS=$(whence ps) ; PS=${PS:-${ROOT:-/}bin/ps}
  local RDCATCHD=$(whence rdcatchd) ; RDCATCHD=${RDCATCHD:-${ROOT:-/}usr/bin/rdcatchd}
  local SED=$(whence sed) ; SED=${SED:-${ROOT:-/}bin/sed}
  local SLEEP=$(whence sleep) ; SLEEP=${SLEEP:-${ROOT:-/}bin/sleep}
  local SORT=$(whence sort) ; SORT=${SORT:-${ROOT:-/}usr/bin/sort}

  local -a dropboxIDs
  local -a rdimportIDs
  local dropboxID dropboxPath rdcatchdRestartNeeded returnValue=0

  # We are looking for dropboxes on *this* host.
  dropboxIDs=( $(doSQL "select ID from DROPBOXES where STATION_NAME = '$(${HOSTNAME} -s)' order by ID") )
  # The list of IDs for all currently running rdimport processes.
  rdimportIDs=(
    $(
      ${PS} ax --format 'pid,args' |
	${AWK} '/\s?rdimport\s?/{print $3}' |
	${SED} -e 's,--persistent-dropbox-id=,,' |
	${SORT} -n
    )
  )

  # Check each one if we found any dropbox IDs.
  if (( ${#dropboxIDs} )) ; then

    # If not equal, we probably have more dropboxes than running
    # instances of rdimport. (This is a map() in perl.)
    for dropboxID in ${dropboxIDs} ; do

      dropboxPath=$(doSQL "select PATH from DROPBOXES where ID=${dropboxID}")

      if ${GREP} -q ${dropboxID} <<<${rdimportIDs} ; then

	logit ${myName} ${interactive} "Dropbox ${dropboxID} ('${dropboxPath}') is running."

      else

	logit ${myName} ${interactive} "Dropbox ${dropboxID} ('${dropboxPath}') is not running. (Will restart rdcatchd.)"
	rdcatchdRestartNeeded=1

      fi
    done

    if (( rdcatchdRestartNeeded )) ; then

      logit ${myName} ${interactive} "Restarting $(( rdcatchdRestartNeeded )) Rivendell dropboxes...${interactive:+ \\c}"

      ${KILLALL} 'rdcatchd'

      # Wait a few seconds to see if anybody restarts rdcatchd.
      if (( interactive )) ; then
	for i in {1..3} ; do echo ".\c" ; ${SLEEP} 1; done
      else
	${SLEEP} 3
      fi

      if ! ${PIDOF} 'rdcatchd' > /dev/null ; then

	${RDCATCHD}

	# Wait a few seconds more to make sure rdcatchd restarts.
	if (( interactive )) ; then
	  for i in {1..3} ; do echo ".\c" ; ${SLEEP} 1; done
	else
	  ${SLEEP} 3
	fi

	if ${PIDOF} 'rdcatchd' > /dev/null ; then

	  logit ${myName} ${interactive} "Done."

	else

	  (( interactive )) && echo
	  logit ${myName} ${interactive} "ERROR: Could not restart ${RDCATCHD}. Please contact a professional Rivendell authority!"
	  returnValue=1

	fi
      fi
    else

      logit ${myName} ${interactive} "Yay! All Rivendell dropboxes are currently active and running."

    fi
  else

    logit ${myName} ${interactive} "Found zero (0) dropboxes on this Rivendell workstation ('$(${HOSTNAME} -s)')."

  fi

}

rdGetDropboxIDFromPath() {
  local myName=${1} ; shift
  local pathPrefix=${1} ; shift
  local verbose=${1}

  local returnValue=1
  local query="select ID from DROPBOXES where PATH like '${pathPrefix}%'"
  local id=$(doSQL "${query}")

  if (( id )) ; then
    echo ${id}
    returnValue=0
  else
    echo -1
  fi

  return ${returnValue}
}

logit() {
  local caller=${1} ; shift
  local interactive=${1} ; shift
  local message="${1}"

  local LOGGER=$(whence logger) ; LOGGER=${LOGGER:-${ROOT:-/}usr/bin/logger}

  if (( interactive )) ; then

    print "${message}" >&2

  else

    ${LOGGER} -t ${caller} -p local7.notice -i "${message}"

  fi
}
# Local Variables: ***
# mode:shell-script ***
# indent-tabs-mode: f ***
# sh-indentation: 2 ***
# sh-basic-offset: 2 ***
# sh-indent-for-do: 0 ***
# sh-indent-after-do: + ***
# sh-indent-comment: t ***
# sh-indent-after-case: + ***
# sh-indent-after-done: 0 ***
# sh-indent-after-else: + ***
# sh-indent-after-if: + ***
# sh-indent-after-loop-construct: + ***
# sh-indent-after-open: + ***
# sh-indent-after-switch: + ***
# sh-indent-for-case-alt: ++ ***
# sh-indent-for-case-label: + ***
# sh-indent-for-continuation: + ***
# sh-indent-for-done: 0 ***
# sh-indent-for-else: 0 ***
# sh-indent-for-fi: 0 ***
# sh-indent-for-then: 0 ***
# End: ***
