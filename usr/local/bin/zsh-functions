#!/bin/zsh

##############################################################################
#
# This is a "library" of zsh(1) functions used by the Broadcast Tool & Die
# Z-Shell scripts. All scripts that need these support functions should
# "source" this file.
#
# This script is NOT intended to be "run" from the command line.
#
##############################################################################

zmodload zsh/datetime

# Use the configured mailer to send email to one or more
# addresses. This relies heavily on msmtp(1) and its configuration
# file.
# Send no more than one notification for each type in 24 hours (and
# let the recipients know that they will see no more than one per
# day).
sendNotification() {
  local myName=${1:?"Who am I?"} ; shift
  local MAILTO="${1:?'Need one or more email addresses to send to.'}" ; shift
  local type=${1:?"Need a notification type."} ; shift
  local message=${1:?"Need a message to send for the notification."} ; shift
  local messagefile=${1} # optional text filename to attach

  local MAILER=$(whence msmtp) ; MAILER=${MAILER:-${ROOT:-/}usr/bin/msmtp}
  local MAILER_CONFIG=${MAILER_CONFIG:-${ROOT:-/}usr/local/etc/pmw/conf.msmtp}
  local MAILER_ARGS=${MAILER_ARGS:-"--read-recipients --read-envelope-from  --file ${MAILER_CONFIG}"}
  local PRETEND=${PRETEND}
  local startTime=${EPOCHSECONDS}
  local returnValue=0

  #################  BEGIN shell commands used in this function.  #################
  # This function uses these 7 external commands.
  # Look for them in their upper case, parameter expanded form.
  local C D
  local -a ourCommands
  ourCommands=(
    awk
    base64
    cat
    dos2unix
    hostname
    logger
    uuidgen
  )
  # Find the executables we need; this uses a little old fashioned shell and
  # a ZSH trick -- the (U) in the eval(1) says to evaluate the parameter as
  # all upper case letters. We will use the command names in upper case as
  # variables by which to call the external commands used in this function.
  for C in ${ourCommands} ; do
    for D in ${path} ; do
      [[ -x ${D}/${C} ]] && { eval ${(U)C}=${D}/${C} ; break }
    done
    [[ -x $(eval echo \$${(U)C}) ]] || { echo "Cannot find ${C}! Done."; return 1 }
  done
  ##################  END shell commands used in this function.  ##################

  local MAIL_FROM=$(${AWK} '/^user /{print $2}' ${MAILER_CONFIG})

  if ! notificationSent ${myName} ${type} ${startTime} ; then
    if [[ -x ${MAILER} ]] ; then
      if [[ -s ${MAILER_CONFIG} ]] ; then
	if [[ -n "${MAIL_FROM}" ]] ; then

	  (
	    ${CAT} <<EOF
To: ${${MAILTO//( |[ ,][ ,])/,}%,}
From: ${MAIL_FROM}
Reply-To: ${MAIL_FROM}
Subject: Notification from ${myName} (${type})
Message-ID: <$(${UUIDGEN})-${startTime}@$(${HOSTNAME} -f)>
X-Script-Name: ${myName}
MIME-Version: 1.0
Content-Type: multipart/mixed;
 boundary="----------${startTime}"

This is a multi-part message in MIME format.
------------${startTime}
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: 8bit

${message}

Note that you will see only one notification per day for this
condition. You may see all notifications (including those for which
no email was sent) by opening a terminal window on $(${HOSTNAME}) and
entering (or pasting) the command:

  journalctl _COMM=logger SYSLOG_IDENTIFIER=notificationSent

EOF
	    if [[ -n "${messagefile}" ]] && [[ -s ${messagefile} ]] ; then
	      ${CAT} <<EOF
------------${startTime}
Content-Type: text/plain; charset=UTF-8;
 name="${messagefile##*/}"
Content-Transfer-Encoding: base64
Content-Disposition: attachment;
 filename="${messagefile##*/}"

$(${DOS2UNIX} < ${messagefile} | ${BASE64})
EOF
	    fi

	    ${CAT} <<EOF
------------${startTime}--
EOF
	  ) | ${MAILER} $(eval echo ${MAILER_ARGS}) ${PRETEND}

	else

	  ${LOGGER} -t ${0##*/} -p local7.err -i "ERROR: Cannot find a From: address in '${MAILER_CONFIG}'. Cannot send messages."
	  returnValue=3

	fi

      else

	${LOGGER} -t ${0##*/} -p local7.err -i "ERROR: Cannot find mailer configuration '${MAILER_CONFIG}'. Cannot send messages."
	returnValue=2

      fi

    else

      ${LOGGER} -t ${0##*/} -p local7.err -i "ERROR: Cannot find executable program '${MAILER}'. Cannot send messages."
      returnValue=1

    fi
  fi

  return ${returnValue}
}

# Make a record of the type and time of a notification
notificationSent() {
  local theirName=${1} ; shift
  local type=${1} ; shift
  local notificationTime=${1}

  local SED=$(whence sed) ; SED=${SED:-${ROOT:-/}bin/sed}
  local notifyDB=${NOTIFY_DB:-${ROOT:-/}usr/local/etc/pmw/notifications}
  local notification
  local foundPriorNotification=0
  local oneDay=$(( 60 * 60 * 24 ))
  local returnValue=1

  # Is there a notification database?
  if [[ -f ${notifyDB} ]] ; then
    while read notification ; do
      if [[ "${notification%:*}" == "${theirName}:${type}" ]] ; then
	foundPriorNotification=1
	break
      fi
    done < ${notifyDB}
    # Have we seen this notification before?
    if (( foundPriorNotification )) ; then
      # Has it been more than a day since we last notified?
      if (( ( notificationTime - oneDay ) > ${notification##*:} )) ; then
	if ${SED} -i -e "s/^${theirName}:${type}:.*$/${theirName}:${type}:${notificationTime}/" ${notifyDB} ; then
	  logit ${0} 0 "${theirName} NOTICE: '${type}' notification UPDATED at $(strftime %F\ %T ${notificationTime})."
	else
	  logit ${0} 0 "${theirName} WARNING: Unable to UPDATE '${type}' notification at $(strftime %F\ %T ${notificationTime}) (${?})."
	  returnValue=2
	fi
      else
	# It has been less than a day since we last notified. We are
	# done here.
	logit ${0} 0 "${theirName} NOTICE: quiet time for notification '${type}' at $(strftime %F\ %T ${notificationTime}) ($(strftime %F\ %T ${notification##*:}))."
	returnValue=0
      fi
    else
      # This is a new notification for this ${theirName} and ${type}
      if echo "${theirName}:${type}:${notificationTime}" >> ${notifyDB} ; then
	logit ${0} 0 "${theirName} NOTICE: '${type}' notification added at $(strftime %F\ %T ${notificationTime})."
      else
	logit ${0} 0 "${theirName} WARNING: Unable to APPEND '${type}' notification at $(strftime %F\ %T ${notificationTime}) (${?})."
	returnValue=3
      fi
    fi
  else
    # No existing notification database, so create it and add this
    # notification to it.
    if echo "${theirName}:${type}:${notificationTime}" > ${notifyDB} ; then
      logit ${0} 0 "${theirName} NOTICE: '${type}' notification created at $(strftime %F\ %T ${notificationTime})."
    else
      logit ${0} 0 "${theirName} WARNING: Unable to CREATE '${type}' notification at $(strftime %F\ %T ${notificationTime}) (${?})."
      returnValue=4
    fi
  fi

  return ${returnValue}
}

# Make mysql calls look a bit more asthetically pleasing. The return
# value of this shell funtion is the exit value of the mysql command
# invocation.
doSQL() {
  local statement="${1:?Need a database query to run.}"
  local useMyCNF=0
  local usableMyCNF=4
  local rdconfig=${RD_CONFIG:-${ROOT:-/}etc/rd.conf}

  #################  BEGIN shell commands used in this function.  #################
  # This function uses these 4 external commands.
  # Look for them in their upper case, parameter expanded form.
  ourCommands=(
    awk
    egrep
    mysql
    sed
  )
  # Find the executables we need; this uses a little old fashioned shell and
  # a ZSH trick -- the (U) in the eval(1) says to evaluate the parameter as
  # all upper case letters. We will use the command names in upper case as
  # variables by which to call the external commands used in this function.
  for C in ${ourCommands} ; do
    for D in ${path} ; do
      [[ -x ${D}/${C} ]] && { eval ${(U)C//-/_}=${D}/${C} ; break }
    done
    [[ -x $(eval echo \$${(U)C//-/_}) ]] || { echo "Cannot find ${C}! Done."; return 1 }
  done
  ##################  END shell commands used in this function.  ##################

  typeset -gx _DB_HOST _DB_USER _DB_PWD _DB_DATABASE _USE_MYCNF

  zmodload zsh/mapfile

  # Use the exported variables if we have been through this function
  # already. This applies to each running instance of scripts that
  # use this function. This helps prevent the need to look this
  # stuff up every time this function is called.
  if [[ -z "${_DB_HOST}" ]] ; then

    # Rivendell DB Details: Use credentials in ~/.my.cnf if it exists,
    # else get credentials from rd.conf if it exists, else from the
    # environment, else use defaults here.
    # BUG ALERT: this assumes the credentials in .my.cnf are relevant
    # to the Rivendell database.
    if [[ -r ~/.my.cnf ]] && [[ $(${EGREP} -c '^(database|host|user|password)' ~/.my.cnf) -ge 4 ]] ; then
      cd -q			# Sigh, mapfile cannot deal with path components.
      myCnfLines=( ${mapfile[.my.cnf]} )

      # Need to check for each of these parameters in .my.cnf in
      # order to be able to use it.
      for parm in database host password user ; do
	if [[ "${myCnfLines}" =~ ${parm} ]] ; then
	  (( useMyCNF++ ))
	fi
      done
    else
      # Horribly insecure, but this is the "Rivendell Way".
      if [[ -r ${rdconfig} ]] ; then
	DB_HOST=$(${SED} -e '1,/^\[mySQL\]$/d' -e '/^\[/,$d' ${rdconfig} | ${AWK} -F'=' '/^Hostname=/{print $2}')
	DB_USER=$(${SED} -e '1,/^\[mySQL\]$/d' -e '/^\[/,$d' ${rdconfig} | ${AWK} -F'=' '/^Loginname=/{print $2}')
	DB_PASSWORD=$(${SED} -e '1,/^\[mySQL\]$/d' -e '/^\[/,$d' ${rdconfig} | ${AWK} -F'=' '/^Password=/{print $2}')
	DB_DATABASE=$(${SED} -e '1,/^\[mySQL\]$/d' -e '/^\[/,$d' ${rdconfig} | ${AWK} -F'=' '/^Database=/{print $2}')
      else
	# Last ditch effort to set the MySQL access credentials.
	# These are the "conventional" defaults that might otherwise
	# exist in /etc/rd.conf (and friends).
	DB_HOST=${RD_DB_HOST:-"localhost"}
	DB_USER=${RD_DB_USER:-"rduser"}
	DB_PASSWORD=${RD_DB_PASS:-"letmein"}
	DB_DATABASE=${RD_DB_DATABASE:-"Rivendell"}
      fi
    fi

    _DB_HOST=${DB_HOST}
    _DB_USER=${DB_USER}
    _DB_PWD=${DB_PASSWORD}
    _DB_DATABASE=${DB_DATABASE}
    _USE_MYCNF=${useMyCNF}
  fi

  if (( _USE_MYCNF == usableMyCNF )) ; then
    ${MYSQL} -s -N -e "${statement}"
  else
    ${MYSQL} -s -N -B -u ${_DB_USER} -p${_DB_PWD} -h ${_DB_HOST} ${_DB_DATABASE} -e "${statement}"
  fi
}

rdDatabaseVersion() {
  doSQL "select DB from VERSION"
}

getMyIPAddresses() {
  local -a ipAddresses
  local returnValue=0

  ################  BEGIN shell commands used in this function.  ################
  # This function uses these 4 external commands.
  # Look for them in their upper case, parameter expanded form.
  ourCommands=(
    awk
    grep
    ip
    sed
  )
  # Find the executables we need; this uses a little old fashioned shell and
  # a ZSH trick -- the (U) in the eval(1) says to evaluate the parameter as
  # all upper case letters. We will use the command names in upper case as
  # variables by which to call the external commands used in this function.
  for C in ${ourCommands} ; do
    for D in ${path} ; do
      [[ -x ${D}/${C} ]] && { eval ${(U)C//-/_}=${D}/${C} ; break }
    done
    [[ -x $(eval echo \$${(U)C//-/_}) ]] || { echo "Cannot find ${C}! Done."; return 1 }
  done
  #################  END shell commands used in this function.  #################

  ipAddresses=( $(${IP} -o -4 addr show |
		     ${GREP} -E -v '^(lo|virbr|tun)' |
		     ${AWK} '{print $4}' |
		     ${SED} -r -e 's,/[[:digit:]]+$,,') )

  if (( ${#ipAddresses} )) ; then
    echo ${(j: :)ipAddresses}
  fi

  return ${returnValue}
}

# Get this hosts Rivendell STATION name. Return TRUE or FALSE
# depending on whether we could figure the name out.
rdGetStationName() {
  local -a myIP
  local stationName foundStationName
  local returnValue=0

  local HOSTNAME=$(whence hostname) ; HOSTNAME=${HOSTNAME:-${ROOT:-/}bin/hostname}
  local myHostname=$(${HOSTNAME} -s)

  # This function is compatible with Rivendell database verson:
  local rdDBVersionCompatible=259

  if (( $(rdDatabaseVersion) > rdDBVersionCompatible )) ; then
    echo "This version of ${0} is not compatible with Rivendell database version '$(rdDatabaseVersion)'."
    return 128
  fi

  # Prefer an exact hostname match.
  stationName=$(doSQL "select NAME from STATIONS where NAME = '${myHostname}'")

  # Otherwise try all our relevant IP addresses.
  if [[ -z "${stationName}" ]] ; then

    for myIP in $(getMyIPAddresses) ; do

      stationName=$(doSQL "select NAME from STATIONS where IPV4_ADDRESS = '${myIP}'")
      [[ -n "${stationName}" ]] && { foundStationName=1 ; break ; }

    done

    if [[ -z "${stationName}" ]] ; then

      # If no match on the IP address, try a fuzzier hostname match.
      stationName=$(doSQL "select NAME from STATIONS where NAME like '%${myHostname}%'")

      if [[ -z "${stationName}" ]] ; then

	logit ${0} 1 "Cannot determine my Rivendell 'STATION' name. Better fix that before continuing."
	returnValue=1

      fi
    fi
  fi

  [[ -n "${stationName}" ]] && echo ${stationName}
  return ${returnValue}
}

# Get the Rivendell Web Server (HTTP_STATION) for this computer.
rdGetWebServer() {
  local returnValue=1

  # This function is compatible with Rivendell database verson:
  local rdDBVersionCompatible=259

  if (( $(rdDatabaseVersion) > rdDBVersionCompatible )) ; then
    echo "This version of ${0} is not compatible with Rivendell database version '$(rdDatabaseVersion)'."
    return 128
  fi

  if myStationName=$(rdGetStationName) ; then
    if myHTTPStationName=$(doSQL "select HTTP_STATION from STATIONS where NAME = '${myStationName}'") ; then
      returnValue=0
      echo ${myHTTPStationName}
    else
      logit ${0} 1 "Could not determine the Rivendell Web Server for this workstation ('${myStationName}')."
    fi
  else
    logit ${0} 1 "Could not determine my host name."
  fi

  return ${returnValue}
}

# Use the Rivendell Web API to execute a command. Unlike most other
# functions in this library, the arg 'verbose' *must* be set to either
# '0' or a positive integer.
rdWebInvoke() {
  local verbose=${1} ; shift
  local command=${1} ; shift
  local -a curlArguments
  curlArguments=( ${*} )

  local oIFS
  local CURL=$(whence curl) ; CURL=${CURL:-${ROOT:-/}usr/bin/curl}
  local curlVerbosity
  local httpServer="$(rdGetWebServer)"
  local -a response
  local responseLine result c
  local headerCount=1
  local returnValue=1

  if (( verbose )) ; then
    curlVerbosity="--verbose"
  else
    curlVerbosity="--silent"
  fi

  # We want each line as its own array element, so set IFS
  # accordingly.
  oIFS="${IFS}"
  IFS='
'

  # Invoke the curl(1) utility with a POST to the server and each "-d"
  # argument containing one attribute/value pair. We --include the
  # headers in the curl output so we can determine the determine the
  # HTTP response.
  # BUG ALERT: this code depends on the Rivendell username 'user' existing with NO password.
  response=( $(${CURL} --include ${curlVerbosity} -d LOGIN_NAME='user' -d PASSWORD='' -d COMMAND=${command} ${curlArguments:+"-d"} ${(zj: -d :)curlArguments} http://${httpServer}/rd-bin/rdxport.cgi) )
  returnValue=${?}
  while read responseLine ; do
    if [[ ${responseLine} =~ '^HTTP/[[:digit:]]+\.[[:digit:]]+ 200 OK' ]] ; then
      result=OK
      break
    elif [[ ${responseLine} =~ 'ErrorString' ]] ; then
      # Strip the XML tag and extract just the "error string".
      result=${${responseLine%</ErrorString>*}#*<ErrorString>}
      break
    fi
  done <<<"${response}"

  # Calculate the end of the HTTP Response Header and strip if from
  # the output of curl(1). We use the fact that the HTTP Response
  # Header is separated from the command output by a blank line (an
  # empty array element).
  for c in {1..${#response}} ; do
    [[ -z "${${(f)response[c]}[2]}" ]] && { (( headerCount=c )) ; break ; }
  done
  shift ${headerCount} response

  if [[ "${result:-MISSING RESULT}" = 'OK' ]] ; then
    returnValue=0
    echo "${response}"
  fi

  IFS="${oIFS}"
    
  return ${returnValue}
}

# Use the Rivendell Web API to list the cart and cut details for the
# specified CART.
# Note that as of Rivendell version 2.10.3 ListCarts is broken if you
# do not provide search parameters to the "query". This is fixed in
# 2.15.1, but for now we *REQUIRE* a GROUP in which to list all CARTs.
rdListAllCarts() {
  local group=${1} ; shift
  local verbose=${1:-0}

  # List cart: Command 6: ListCarts
  local command=6
  local -a curlArguments
  local -a result
  local returnValue

  curlArguments=("GROUP_NAME=${group}")

  result=$(rdWebInvoke ${verbose} ${command} ${curlArguments})
  returnValue=${?}

  echo "${result}"
  return ${returnValue}
}

# Use the Rivendell Web API to list the CART. The second
# arg, 0 (default) or 1 to list CUTS.
rdListCart() {
  local cartNumber=${1} ; shift
  local withCuts=${1:-0}
  local verbose=${2:-0}

  local command=7
  local -a curlArguments
  local -a result
  local returnValue

  # List cart: Command 7: ListCart
  curlArguments=( "CART_NUMBER=${cartNumber}" "INCLUDE_CUTS=${withCuts}" )

  result=$(rdWebInvoke ${verbose} ${command} ${curlArguments})
  returnValue=${?}

  echo "${result}"
  return ${returnValue}
}

# Use the Rivendell Web API to list all the CUTS for the specified
# CART.
rdListCuts() {
  local cartNumber=${1} ; shift
  local verbose=${1:-0}

  local command=9
  local -a curlArguments
  local result
  local returnValue

  # List cuts: Command 9: ListCuts
  # BUG ALERT: this code depends on the Rivendell username 'user' existing with NO password.
  curlArguments=( "CART_NUMBER=${cartNumber}" )

  result=$(rdWebInvoke ${verbose} ${command} ${curlArguments})
  returnValue=${?}

  echo "${result}"
  return ${returnValue}
}

# Use the Rivendell Web API to delete the CART, all its CUTS, and the
# actual audio file for the specified CART.
rdDropCart() {
  local cartNumber=${1} ; shift
  local verbose=${1:-0}

  local command=13
  local -a curlArguments
  local result
  local returnValue

  # Delete this cart (and all its cuts): Command 13: RemoveCart
  # BUG ALERT: this code depends on the Rivendell username 'user' existing with NO password.
  curlArguments=( "CART_NUMBER=${cartNumber}" )

  result=$(rdWebInvoke ${verbose} ${command} ${curlArguments})
  returnValue=${?}

  echo "${result}"
  return ${returnValue}
}

# Use the Rivendell Web API to delete the specified CUT, and the
# actual audio file.
rdDropCut() {
  local cartNumber=${1} ; shift
  local cutNumber=${1} ; shift
  local verbose=${1:-0}

  local command=11
  local -a curlArguments
  local response result
  local returnValue

  # Delete this cut: Command 11: RemoveCut
  curlArguments=( "CART_NUMBER=${cartNumber}" "CUT_NUMBER=${cutNumber}" )

  result=( $(rdWebInvoke ${verbose} ${command} ${curlArguments}) )
  returnValue=${?}

  echo "${result}"
  return ${returnValue}

  [[ "${result:-MISSING RESULT}" = 'OK' ]] && returnValue=0
  echo "${result:-MISSING RESULT}"
  return ${returnValue}
}

# Use the Rivendell Web API to list all the CUTS for the specified
# CART.
rdListGroups() {
  local verbose=${1:-0}

  local command=4
  local -a curlArguments
  local result
  local returnValue

  # List cuts: Command 9: ListCuts
  # BUG ALERT: this code depends on the Rivendell username 'user' existing with NO password.
  curlArguments=()

  result=$(rdWebInvoke ${verbose} ${command} ${curlArguments})
  returnValue=${?}

  echo "${result}"
  return ${returnValue}
}

# Get a Rivendell CART NUMBER from a TITLE (full or partial).
rdCartNumberFromTitle() {
  local title=${1:?"Need a CART TITLE string to search."} ; shift
  local verbose=${1}

  doSQL "select NUMBER from CART where TITLE = '${title}'"
}

# Get a Rivendell CART TITLE from a partial TITLE.
rdCartTitleFromPartial() {
  local title=${1:?"Need a CART TITLE string to search."} ; shift
  local verbose=${1}

  doSQL "select TITLE from CART where TITLE like '%${title}%'"
}

# Get a Rivendell CART TITLE from a CART NUMBER.
rdCartTitleFromNumber() {
  local number=${1:?"Need a CART NUMBER to look up."} ; shift
  local verbose=${1}

  doSQL "select TITLE from CART where NUMBER = ${number}"
}

rdCartGroupFromNumber() {
  local number=${1:?"Need a CART NUMBER to search."} ; shift
  local verbose=${1}

  doSQL "select GROUP_NAME from CART where NUMBER = ${number}"
}

rdMaxCartNumberForGroup() {
  local group=${1:?"Need a GROUP_NAME from which to get the next CART NUMBER."} ; shift
  local verbose=${1}

  # This function is compatible with Rivendell database verson:
  local rdDBVersionCompatible=259

  if (( $(rdDatabaseVersion) > rdDBVersionCompatible )) ; then
    echo "This version of ${0} is not compatible with Rivendell database version '$(rdDatabaseVersion)'."
    return 128
  fi

  local maxCartNum=$(doSQL "select DEFAULT_HIGH_CART from GROUPS where NAME = '${group}'")

  echo ${maxCartNum}
}

rdGetNextCartNumber() {
  local group=${1:?"Need a GROUP_NAME from which to get the next CART NUMBER."} ; shift
  local verbose=${1}

  local currentCartNumber
  local returnValue=0
  local defaultLowCart defaultHighCart nextAvailable nextCartNum useThisCartNumber
  local lastHigh=0

  # This function is compatible with Rivendell database verson:
  local rdDBVersionCompatible=259

  if (( $(rdDatabaseVersion) > rdDBVersionCompatible )) ; then
    echo "This version of ${0} is not compatible with Rivendell database version '$(rdDatabaseVersion)'."
    return 128
  fi

  # Get the next available cart number from the group if the group is
  # constrained with default low and default high numbers.
  read defaultLowCart defaultHighCart <<<$(doSQL "select DEFAULT_LOW_CART,DEFAULT_HIGH_CART from GROUPS where NAME = '${group}'")
  (( verbose )) && echo "defaultLowCart: ${defaultLowCart}, defaultHighCart: ${defaultHighCart}" >&2
  if (( defaultLowCart )) ; then

    nextAvailable=${defaultLowCart}
    while (( nextAvailable < defaultHighCart )) ; do

      # Try to find an unused cart number starting at
      # DEFAULT_LOW_CART.
      currentCartNumber=$(doSQL "select NUMBER from CART where NUMBER = ${nextAvailable}")
      if (( currentCartNumber )) ; then

	(( nextAvailable++ ))

      else

	useThisCartNumber=${nextAvailable}
	break

      fi
    done

    if (( nextAvailable == defaultHighCart )) ; then

      # Return an error because we hit the end of the group range and
      # did not find a free CART number.
      useThisCartNumber=-1
      returnValue=1

    fi
  else

    # No default low cart in this group (i.e., there is no number
    # range for this group), so find the next available cart number
    # outside all group ranges.
    doSQL 'select DEFAULT_LOW_CART,DEFAULT_HIGH_CART from GROUPS where DEFAULT_LOW_CART > 0 order by DEFAULT_LOW_CART' |
      while read defaultLowCart defaultHighCart ; do

	# Skip this group if its range falls within a previous group
	# range (yes, this can happen).
	(( defaultLowCart < lastHigh )) && continue

	if (( nextAvailable > lastHigh && nextAvailable < defaultLowCart )) ; then

	  # This query will return NULL if there are no assigned carts
	  # in this range, or the highest assigned cart number in the
	  # range.
	  nextCartNum=$(doSQL "select max(NUMBER) from CART where NUMBER >= ${nextAvailable} and NUMBER < ${defaultLowCart}")
	  if [[ -z "${nextCartNum}" ]] || [[ "${nextCartNum}" = 'NULL' ]] ; then

	    useThisCartNumber=${nextAvailable}
	    break

	  fi
	else

	  (( nextAvailable = defaultHighCart + 1 ))

	fi

	lastHigh=${defaultHighCart}
      done
  fi

  if (( useThisCartNumber > 0 )) ; then

    echo ${useThisCartNumber}

  else

    echo "${0}: ERROR: Cannot find the next CART number for GROUP '${group}' (MAX=$(rdMaxCartNumberForGroup ${group}), Next=${nextAvailable})." >&2

  fi

  return ${returnValue}
}

rdCreateEmptyCart() {
  local group=${1:?"Need to specify a GROUP_NAME in which to create the new CART."} ; shift
  local title=${1:?"Need a CART TITLE string to search."} ; shift
  local verbose=${1}

  local -a query
  local newCartNumber
  local returnValue=0

  # This function is compatible with Rivendell database verson:
  local rdDBVersionCompatible=259

  if (( $(rdDatabaseVersion) > rdDBVersionCompatible )) ; then
    echo "This version of ${0} is not compatible with Rivendell database version '$(rdDatabaseVersion)'."
    return 128
  fi

  if newCartNumber=$(rdGetNextCartNumber ${group}) ; then

    if (( newCartNumber > 0 )) ; then

      # Place the query clauses into an array, mostly for visibility.
      query=(
	"insert into CART"
	"(NUMBER, TYPE, GROUP_NAME, TITLE, CUT_QUANTITY)"
	"values"
	"(${newCartNumber}, 1, '${group}', '${title}', 0)"
      )

      doSQL "${(j: :)query}"
      echo ${newCartNumber}

    else

      echo "${0}: ERROR: Could not create a new CART ('${title}') in GROUP '${group}'." >&2
      returnValue=1

    fi
  fi

  return ${returnValue}
}

rdDropboxStatus() {
  local myName=${1} ; shift
  local interactive=${1} ; shift
  local verbose=${1}

  #################  BEGIN shell commands used in this function.  #################
  # This function uses these 10 external commands.
  # Look for them in their upper case, parameter expanded form.
  local C D
  local -a ourCommands
  ourCommands=(
    awk
    grep
    hostname
    killall
    pidof
    ps
    rdcatchd
    sed
    sleep
    sort
  )
  # Find the executables we need; this uses a little old fashioned shell and
  # a ZSH trick -- the (U) in the eval(1) says to evaluate the parameter as
  # all upper case letters. We will use the command names in upper case as
  # variables by which to call the external commands used in this function.
  for C in ${ourCommands} ; do
    for D in ${path} ; do
      [[ -x ${D}/${C} ]] && { eval ${(U)C}=${D}/${C} ; break }
    done
    [[ -x $(eval echo \$${(U)C}) ]] || { echo "Cannot find ${C}! Done."; return 1 }
  done
  ##################  END shell commands used in this function.  ##################

  local -a dropboxIDs
  local -a rdimportIDs
  local dropboxID dropboxPath rdcatchdRestartNeeded=0 returnValue=0
  local count=0 totalCount=0

  # We are looking for dropboxes on *this* host.
  dropboxIDs=( $(doSQL "select ID from DROPBOXES where STATION_NAME = '$(${HOSTNAME} -s)' order by ID") )
  # The list of IDs for all currently running rdimport processes.
  rdimportIDs=(
    $(
      ${PS} ax --format 'pid,args' |
	${AWK} '/\s?rdimport\s?/{print $3}' |
	${SED} -e 's,--persistent-dropbox-id=,,' |
	${SORT} -n
    )
  )

  # Check each one if we found any dropbox IDs.
  if (( ${#dropboxIDs} )) ; then

    # If not equal, we probably have more dropboxes than running
    # instances of rdimport. (This is a map() in perl.)
    for dropboxID in ${dropboxIDs} ; do

      dropboxPath=$(doSQL "select PATH from DROPBOXES where ID=${dropboxID}")

      if ${GREP} -q ${dropboxID} <<<${rdimportIDs} ; then

	logit ${myName} ${interactive} "Dropbox ${dropboxID} ('${dropboxPath}') is running."
	(( count++ ))

      else

	logit ${myName} ${interactive} "Dropbox ${dropboxID} ('${dropboxPath}') is not running. (Will restart rdcatchd.)"
	(( rdcatchdRestartNeeded++ ))

      fi
      (( totalCount++ ))
    done

    if (( rdcatchdRestartNeeded )) ; then

      logit ${myName} ${interactive} "${count} of ${totalCount} Rivendell dropboxes are running. Restarting $((rdcatchdRestartNeeded)) Rivendell dropboxes...${interactive:+ \\c}"

      ${KILLALL} 'rdcatchd'

      # Wait a few seconds to see if anybody restarts rdcatchd.
      if (( interactive )) ; then
	for i in {1..3} ; do echo ".\c" ; ${SLEEP} 1; done
      else
	${SLEEP} 3
      fi

      if ! ${PIDOF} 'rdcatchd' > /dev/null ; then

	${RDCATCHD}

	# Wait a few seconds more to make sure rdcatchd restarts.
	if (( interactive )) ; then
	  for i in {1..3} ; do echo ".\c" ; ${SLEEP} 1; done
	else
	  ${SLEEP} 3
	fi

	if ${PIDOF} 'rdcatchd' > /dev/null ; then

	  logit ${myName} ${interactive} "Done."

	else

	  (( interactive )) && echo
	  logit ${myName} ${interactive} "ERROR: Could not restart ${RDCATCHD}. Please contact a professional Rivendell authority!"
	  returnValue=1

	fi
      fi
    else

      logit ${myName} ${interactive} "Yay! ${count} of ${totalCount} Rivendell dropboxes are currently active and running."

    fi
  else

    logit ${myName} ${interactive} "Found zero (0) dropboxes on this Rivendell workstation ('$(${HOSTNAME} -s)')."

  fi

}

rdGetDropboxIDFromPath() {
  local myName=${1} ; shift
  local pathPrefix=${1} ; shift
  local interactive=${1} ; shift
  local verbose=${1}

  local returnValue=1
  local query="select ID from DROPBOXES where PATH like '${pathPrefix}%'"
  local -a id

  # The query *should* return exactly one dropbox ID; deal with it
  # gracefully if it returns more than one.
  id=( $(doSQL "${query}") )
  if (( ${#id} > 1 )) ; then
    logit ${myName} ${interactive} "Unable to determine the exact DROPBOX ID for ${pathPrefix}. Make sure this is a unique path."
  else
    if (( id[1] )) ; then
      echo ${id}
      returnValue=0
    else
      echo -1
    fi
  fi

  return ${returnValue}
}

logit() {
  local caller=${1} ; shift
  local interactive=${1} ; shift
  local message="${1}"

  local LOGGER=$(whence logger) ; LOGGER=${LOGGER:-${ROOT:-/}usr/bin/logger}

  if (( interactive )) ; then

    print "${message}" >&2

  else

    ${LOGGER} -t ${caller} -p local7.notice -i "${message}"

  fi
}

# Local Variables: ***
# mode:shell-script ***
# indent-tabs-mode: f ***
# sh-indentation: 2 ***
# sh-basic-offset: 2 ***
# sh-indent-for-do: 0 ***
# sh-indent-after-do: + ***
# sh-indent-comment: t ***
# sh-indent-after-case: + ***
# sh-indent-after-done: 0 ***
# sh-indent-after-else: + ***
# sh-indent-after-if: + ***
# sh-indent-after-loop-construct: + ***
# sh-indent-after-open: + ***
# sh-indent-after-switch: + ***
# sh-indent-for-case-alt: ++ ***
# sh-indent-for-case-label: + ***
# sh-indent-for-continuation: + ***
# sh-indent-for-done: 0 ***
# sh-indent-for-else: 0 ***
# sh-indent-for-fi: 0 ***
# sh-indent-for-then: 0 ***
# End: ***
