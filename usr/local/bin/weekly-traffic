#!/bin/zsh

##########################################################################################
##########################################################################################
##
## weekly-traffic
##
## A BTD tool to report on weekly traffic events.
##
##########################################################################################
##########################################################################################

setopt NO_CASE_MATCH
zmodload zsh/regex
zmodload zsh/datetime
zmodload zsh/terminfo
zmodload zsh/stat
autoload colors
colors

# This script complies with Semantic Versioning: http://semver.org/
vMajor=0
vMinor=1
vPatch=1
vHash='$Hash$'

#################  BEGIN shell commands used in this script.  #################
# This script uses these 4 external commands.
# Look for them in their upper case, parameter expanded form.
ourCommands=(
  cat
  getopt
  sort
  tr
)
# Find the executables we need; this uses a little old fashioned shell and
# a ZSH trick -- the (U) in the eval(1) says to evaluate the parameter as
# all upper case letters. We will use the command names in upper case as
# variables by which to call the external commands used in this script.
for C in ${ourCommands} ; do
  for D in ${path} ; do
    [[ -x ${D}/${C} ]] && { eval ${(U)C//-/_}=${D}/${C} ; break }
  done
  [[ -x $(eval echo \$${(U)C//-/_}) ]] || { echo "Cannot find ${C}! Done."; return 1 }
done
##################  END shell commands used in this script.  ##################

# Tell them how to use this command.
usage() {
    myName=${1}

    ${CAT} << EOF
${myName}: Generate a weekly traffic report for the week ending "yesterday".

Summary: ${myName:t} --group (-g) <Traffic Group Name>
                        --service (-s) <Service Name>

Both the --group (-g) and --service (-s) parameters are required.

EOF
}

# Get zsh functions necessary for this script.
if [[ -r ${ROOT:-/}usr/local/bin/zsh-functions ]] ; then
  source ${ROOT:-/}usr/local/bin/zsh-functions
else
  exit $(error "Cannot read support library '${ROOT:-/}usr/local/bin/zsh-functions'. Please consult your tarot card reader!")
fi

# use getopt to parse the command line args
TEMP=$(${GETOPT} -o hg:s:v --long help,group:,service:,version -n ${0:t} -- "${@}")
if [[ ${?} != 0 ]] ; then echo "Terminating..." >&2 ; exit 1 ; fi
# Note the quotes around "$TEMP": they are essential!
eval set -- "${TEMP}"
while :
do
  case "${1}" in
      -g|--grou*) group=${2} ; shift 2 ;;
      -s|--serv*) service=${2} ; shift 2 ;;
      -h|--help) usage ${0} ; exit ;;
      -v|--vers*) showVersion=1 ; shift ;;
      --) shift ; break ;;
      *) echo "Internal error, cannot continue!" ; exit 1 ;;
  esac
done
unset TEMP

if ((showVersion)) ; then
  echo "${0:t}: version ${vMajor}.${vMinor}.${vPatch}-${${vHash#\$Hash: }%$}"
  exit 0
fi

typeset -A cartCount

# Start date is midnight seven days ago.
reportStartDate=$(strftime "%F 00:00:00" $(( EPOCHSECONDS - ( 60 * 60 * 24 *7 ) )))

# End date is (almost) Midnight today (that is, report on everything
# through yesterday).
reportEndDate=$(strftime "%F 23:59:59" $(( ${EPOCHSECONDS} - (60 * 60 * 24) )))

# How many events will we report?
selectCountStatement="SELECT
  COUNT(*)
  FROM ${service}_SRT
  WHERE cart_number IN
  (SELECT number FROM CART WHERE group_name = '${group}')
  AND
  event_datetime > '${reportStartDate}'
  AND
  event_datetime <= '${reportEndDate}'
  ORDER BY event_datetime"
eventCount=$(doSQL "${selectCountStatement}")

# The header.
reportTitleText="${service}: ${eventCount} Traffic Events from ${reportStartDate% *} to ${reportEndDate% *}"

print "${reportTitleText}\n"
printf "%19s\t%6s\t%5s\t%s\n" "Air Date     " "Cart #" "Len " "Cart Title"

# Find all the events from the _SRT table.
selectStatement="SELECT
  event_datetime, title, cart_number, length/1000
  FROM ${service}_SRT
  WHERE cart_number IN
  (SELECT number FROM CART WHERE group_name = '${group}')
  AND
  event_datetime > '${reportStartDate}'
  AND
  event_datetime <= '${reportEndDate}'
  ORDER BY event_datetime"

# Output fields are <Tab>-separated.
doSQL "${selectStatement}" | while read line ; do

  airDateTime=${line%%	*}
  cartTitle=${${line#*	}%%	*}
  cartNumber=${${line%	*}##*	}
  cartLength=${line##*	}
  cartMinSec=$(printf "%02d:%02d" $(( cartLength / 60 )) $(( $(printf "%2.0f" ${cartLength}) % 60 )))

  # Insert a blank line between days.
  [[ ${airDateTime% *} =~ ${lastAirDate} ]] || echo

  printf "%19s\t%06d\t%5s\t%s\n" ${airDateTime} ${cartNumber} ${cartMinSec} ${cartTitle}
  cartCount[${cartNumber}]=$(expr ${cartCount[${cartNumber}]} + 1)

  lastAirDate=${airDateTime% *}

done

print "\nPerformance Totals:"
printf "%6s\t%3s\t%s\n" 'Cart #' 'Plays' 'Cart Title'

for cart in $(echo ${(k)cartCount} | ${TR} ' ' '\012' | ${SORT} -n) ; do

  printf "%06d\t%5d\t%s\n" ${cart} ${cartCount[${cart}]} "$(rdCartTitleFromNumber ${cart})"

done

exit

# Local Variables: ***
# mode:shell-script ***
# indent-tabs-mode: f ***
# sh-indentation: 2 ***
# sh-basic-offset: 2 ***
# sh-indent-for-do: 0 ***
# sh-indent-after-do: + ***
# sh-indent-comment: t ***
# sh-indent-after-case: + ***
# sh-indent-after-done: 0 ***
# sh-indent-after-else: + ***
# sh-indent-after-if: + ***
# sh-indent-after-loop-construct: + ***
# sh-indent-after-open: + ***
# sh-indent-after-switch: + ***
# sh-indent-for-case-alt: ++ ***
# sh-indent-for-case-label: + ***
# sh-indent-for-continuation: + ***
# sh-indent-for-done: 0 ***
# sh-indent-for-else: 0 ***
# sh-indent-for-fi: 0 ***
# sh-indent-for-then: 0 ***
# End: ***
