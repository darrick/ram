#!/bin/zsh

##########################################################################################
##########################################################################################
##
##
## btd-dropbox-check
##
## Examine the current state of all the Rivendell dropboxes on the current host (usually
## TABLE_NAME.station_name in the Rivendell database) and restart rdcatchd(8) if all
## instances of rdimport are not running.
##
##
##########################################################################################
##########################################################################################

setopt NO_CASE_MATCH
zmodload zsh/regex
zmodload zsh/datetime
zmodload zsh/terminfo
zmodload zsh/stat
autoload colors
colors

# This script complies with Semantic Versioning: http://semver.org/
vMajor=0
vMinor=0
vPatch=3
vHash='$Hash$'

export PATH=/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/${HOME}/.local/bin:/${HOME}/bin

# Get zsh functions necessary for this script.
if [[ -r ${ROOT:-/}usr/local/bin/zsh-functions ]] ; then
  source ${ROOT:-/}usr/local/bin/zsh-functions
else
  exit $(error "Cannot read support library '${ROOT:-/}usr/local/bin/zsh-functions'. Please consult your tarot card reader!")
fi

##########################################################################################
## Locally defined subroutines
##########################################################################################

# How to use this command.
usage() {
  myName=${1}

  ${CAT} << EOF
${myName}: check and restart (if necessary) all Rivendell dropbox processes.

Summary: ${myName##*/} [ --verbose (-v) ] [ --version (-V) ]

EOF
}

# Return a line-separated list of all dropbox paths, or (optionally)
# just the paths for the named host. Strip the 'basename' or
# right-most components of the paths before returning them.
getDropboxPaths() {
  local stationName=${1} ; shift
  local verbose=${1} ; shift

  local whereClause
  local query="SELECT path FROM DROPBOXES"
  local -a paths

  if [[ -n "${stationName}" ]] ; then
    whereClause=" WHERE station_name = '${stationName}'"
  fi

  paths=( $(doSQL "${query}${whereClause:+${whereClause}}") )

  (( verbose )) && echo "${0}: paths: ${paths}" >&2

  # Output the paths with the 'basename' component stripped off. See
  # zshparam(1) for details.
  echo ${paths:h}
}

# Return a line-separated list of all dropbox log paths, or (optionally)
# just the log paths for the named host.
getDropboxLogPaths() {
  local stationName=${1} ; shift
  local verbose=${1} ; shift

  local whereClause
  local query="SELECT log_path FROM DROPBOXES"
  local -a logPaths

  if [[ -n "${stationName}" ]] ; then
    whereClause=" WHERE station_name = '${stationName}'"
  fi

  logPaths=( $(doSQL "${query}${whereClause:+${whereClause}}") )

  (( verbose )) && echo "${0}: logPaths: ${logPaths}" >&2

  # Output the full log paths with the 'basename' component included.
  echo ${logPaths}
}
  

warning() {
  local message=${1}

  ${CAT} >&2 <<EOF

${BOLD}${YELLOW}WARNING:${NORM} $(${FMT} -w $(echo $((${COLUMNS:-80} - 2))) <<< ${message})

EOF
}

error() {
  local message=${1}

  ${CAT} >&2 <<EOF

${RED}${BOLD}ERROR:${NORM} $(${FMT} -w $(echo $((${COLUMNS:-80} - 2))) <<< ${message})

EOF
  echo 254
  return 254
}

##########################################################################################
## Script main line
##########################################################################################

RED="${fg_bold[red]}"
YELLOW="${fg_bold[yellow]}"
BOLD="${bold_color}"
NORM="${reset_color}"
# This script is compatible with Rivendell database verson:
rdDBVersionCompatible=259

#################  BEGIN shell commands used in this script.  #################
# This script uses these 10 external commands.
# Look for them in their upper case, parameter expanded form.
ourCommands=(
  cat
  chmod
  find
  fmt
  getopt
  mkdir
  pidof
  sleep
  touch
  xargs
)
# Find the executables we need; this uses a little old fashioned shell and
# a ZSH trick -- the (U) in the eval(1) says to evaluate the parameter as
# all upper case letters. We will use the command names in upper case as
# variables by which to call the external commands used in this script.
for C in ${ourCommands} ; do
  for D in ${path} ; do
    [[ -x ${D}/${C} ]] && { eval ${(U)C//-/_}=${D}/${C} ; break }
  done
  [[ -x $(eval echo \$${(U)C//-/_}) ]] || { echo "Cannot find ${C}! Done."; return 1 }
done
##################  END shell commands used in this script.  ##################

VERBOSE=0

TEMP=$(${GETOPT} -o hVv --long help,version,verbose -n "${0##*/}" -- "${@}")
if (( ${?} != 0 )) ; then echo "${BOLD}getopt error: ${?}. Seek professional help. Terminating.${NORM}" >&2 ; return ${?} ; fi
# Note the quotes around ${TEMP}: they are essential!
eval set -- "${TEMP}"
while : ; do
  case "${1}" in
    -h|--help*) usage ${0##*/} ; exit ;;
    -v|--verb*) VERBOSE=1 ; PASSFILE=none ; shift ;;
    -V|--vers*) showVersion=1 ; shift ;;
    --) shift ; break ;;
    *) echo "${BOLD}getopt internal error (${?})! Seek help!${NORM}" >&2 ; return ${?} ;;
  esac
done

if ((showVersion)) ; then
  echo "${0##*/}: version ${vMajor}.${vMinor}.${vPatch}-${${vHash#\$Hash: }%$}"
  exit 0
fi

# Get all the dropbox paths for this host.
typeset -a dropboxPaths dropboxLogPaths
dropboxPaths=( $(getDropboxPaths "$(rdGetStationName)" ${VERBOSE}) )
# Get all the dropbox log file paths for this host.
dropboxLogPaths=( $(getDropboxLogPaths "$(rdGetStationName)" ${VERBOSE}) )

# Make sure the dropbox paths are accessible.
for dir in ${dropboxPaths} ; do
  if [[ -d ${dir} ]] ; then
    if [[ -w ${dir} ]] ; then
      : all seems well with this directory
    else
      warning "Dropbox folder '${dir}' exists, but is not writeable. Please correct the permissions on this folder."
    fi
  else
    if ${MKDIR} -p ${dir} ; then
      : Created missing dropbox folder '${dir}'
    else
      warning "Could not create missing dropbox folder '${dir}' (${?}). Please check and correct permissions of the parent folder '${dir:h}'."
    fi
  fi
done

# Avoid infinite loops.
passes=0
# Make sure the log files are writeable
for logfile in ${dropboxLogPaths} ; do
  if [[ -w "${logfile}" ]] ; then
    : all seems well with this file
  elif [[ -f "${logfile}" ]] ; then
    # Check the permissions of the directory that contains the logfile.
    if [[ -w ${logfile:h} ]] ; then
      until [[ -w ${logfile} ]] ; do
	if ${CHMOD} +w ${logfile} ; then
	  ${TOUCH} ${logfile}
	else
	  warning "Could not set '${logfile}' to be writeable (${?}). Please seek professional help."
	fi
	if (( passes++ > 4 )) ; then
	  warning "Tried $((passes - 1)) times to make '${logfile}' writeable without success. I give up."
	  break
	fi
	${SLEEP} 1
      done
    elif [[ -d ${logfile:h} ]] ; then
      # See if we can set the directory to be writeable.
      if ${CHMOD} u+w ${logfile:h} ; then
	if ${TOUCH} ${logfile} ; then
	  : able to write the log file, so move on
	else
	  warning "Cannot write to the dropbox log file '${logfile}'. Please check and correct the permissions of this file."
	fi
      else
	warning "The log file folder '${logfile:h}' exists, but is missing write (create) permissions. Please check and correct the permissions of this folder."
      fi
    else
      if ${MKDIR} ${logfile:h} ; then
	if ${TOUCH} ${logfile} ; then
	  : all is corrected
	else
	  warning "Odd. I was able to create the missing log file folder ${logfile:h}, but I cannot create the log file '${logfile}'. Please seek expert help."
	fi
      else
	warning "The log file folder '${logfile:h}' does not exist and I was unable to create it. Please seek the help of a sage."
      fi
    fi
    warning "Cannot write to the dropbox log file '${logfile}'. Please check and correct the permissions of this file."
  else
  fi
done

# Check the dropbox status and restart the dropboxes if necessary.
echo "Checking the status of all active dropboxes ..."
rdDropboxStatus ${0:t} 1 ${VERBOSE}
${SLEEP} 2 

# Make sure rdimport is running before touching all the files
# in the incoming folder.
if ${PIDOF} rdimport > /dev/null 2>&1 ; then
  echo "Done. Searching for stray, un-imported audio files... \c"

  # Search for audio files (names ending in ".(flac|mp2|mp3|ogg|wav)")
  # in all the directories in ${dropboxPaths}. Touch them in order to
  # make rdimport think they are new files.
  # WARNING: this REQUIRES that all dropbox path directories are free
  # of <Space>es.
  typeset -a allFoundFiles
  for dir in $(echo ${dropboxPaths} | tr ' ' '\012' | sort -u); do
    foundFiles=$(${FIND} ${dir} -type f -regextype 'posix-egrep' -iregex '.*\.(flac|mp2|mp3|ogg|wav)' -print 2>/dev/null | ${XARGS} --no-run-if-empty touch)

    if (( VERBOSE )) && [[ -n "${foundFiles}" ]] ; then
      ${FMT} -w $(echo $((${COLUMNS:-80} - 2))) <<< ${foundFiles}
    fi

    # Save any stray file names.
    allFoundFiles=( $(echo ${allFoundFiles} ${foundFiles} | tr ' ' '\012' | sort -u) )
  done

  echo "\nComplete. \c"

  if (( ${#allFoundFiles} )) ; then
    echo "Found ${#allFoundFiles} audio files waiting to be imported."
  fi

  echo "Press <Enter> to continue."
  read proceed
else
  # rdimport seems to be not running.
  ${CAT} << EOF
    rdimport does not seem to be running.

    Make sure the Rivendell database is available and try starting it again
    (by running this script again).

    Press <Enter> to continue.

EOF
  read proceed
fi

exit

# Local Variables: ***
# mode:shell-script ***
# indent-tabs-mode: f ***
# sh-indentation: 2 ***
# sh-basic-offset: 2 ***
# sh-indent-for-do: 0 ***
# sh-indent-after-do: + ***
# sh-indent-comment: t ***
# sh-indent-after-case: + ***
# sh-indent-after-done: 0 ***
# sh-indent-after-else: + ***
# sh-indent-after-if: + ***
# sh-indent-after-loop-construct: + ***
# sh-indent-after-open: + ***
# sh-indent-after-switch: + ***
# sh-indent-for-case-alt: ++ ***
# sh-indent-for-case-label: + ***
# sh-indent-for-continuation: + ***
# sh-indent-for-done: 0 ***
# sh-indent-for-else: 0 ***
# sh-indent-for-fi: 0 ***
# sh-indent-for-then: 0 ***
# End: ***
